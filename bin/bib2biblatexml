#!/usr/bin/perl 
use strict;
use warnings;
no warnings 'utf8';
use Regexp::Common qw /balanced/;
use Text::BibTeX;
use XML::Writer;
use IO::File;
use Encode;
use File::Copy;
use open IO => ':encoding(utf8)';
binmode( STDOUT, ':utf8' );

### biblatex fields

my @namefields = qw/
	author
	editor
	commentator
	translator
	redactor
	bookauthor
	afterword
	introduction
	holder
	sortname
	namea
	nameb
	namec
	/;

my @listfields =
  qw/location
	address
	publisher
	institution
	organization
	school
	origlocation
	language
	lista
	listb
	listc
	listd
	liste
	listf 
	/;

my @titlefields = 
  qw/title 
    subtitle
	titleaddon
	shorttitle
	sorttitle
	indextitle
	indexsorttitle
	origtitle
	issuetitle
	issuesubtitle
	maintitle
	mainsubtitle
	maintitleaddon
	booktitle
	booksubtitle
	booktitleaddon
	journal
	journaltitle
	journalsubtitle
	reprinttitle /;

my @otherfields = qw/
	crossref
	xref
	date
	day
	month
	year
	origyear
	edition
	chapter
	volume
	volumes
	number
	pagetotal
	part
	shortauthor
	shorteditor
	note
	addendum
	annotation
	doi
	id
	isan
	isbn
	ismn
	isrn
	issn
	iswc
	lccn
	url
	urldate
	urlday
	urlmonth
	urlyear
	file
	pdf
	library
	abstract
	keywords
	hyphenation
	label
	options
	presort
	shorthand
	sortkey
	key
	sortyear
	useprefix
	reprintinfo
	/;
# 	pages -> done manually
# THESE ARE ATTRIBUTES:
#	howpublished
#	type

my @cb_topicfields = qw/
	culture
	language
	country
	person
	century
	author
	works
	/;

my %aliases = ( 
	'address' => 'location',
	'school'  => 'institution',
	'annote'  => 'annotation',
	'key'     => 'sortkey'
);

my @entriestosplit = ( @namefields, @listfields); 

my $filename = $ARGV[0];

my $preamble   = "";
my %bibentries = ();

my $bib = new Text::BibTeX::File $filename
  || die "Cannot create Text::BibTeX::File object from $filename: $!";

#TODO validate with Text::BibTeX::Structure ?

sub parsename {
    my $key     = shift;
    my $namestr = shift;
    my $last;
    my $first = undef;
    my $pre   = undef;
    my $suf   = undef;
	
	my $diacritics = qr/[\x{2bf}\x{2018}]/; # ʿ‘ what else? FIXME
	my $semiticprefix = qr/\p{Ll}{2}-/; # etc

    if ( $namestr =~ /,.+,/ ) {    # <pre> Lastname, suffix, Firstname
        ( $pre, $last, $suf, $first ) = $namestr =~
m/^(\p{Ll}(?:\p{Ll}|\s)+)?\s*(\p{Lu}[^,]+|{[^\\][^,]+}),\s+([^,]+),\s+([^,]+)$/;

        #$last =~ s/^{(.+)}$/$1/g ;
        #$first =~ s/^{(.+)}$/$1/g ;
        $pre =~ s/\s+$// if $pre;
    }
    elsif ( $namestr =~ /,/ ) {    # pre? Lastname, Firstname
        ( $pre, $last, $first ) = $namestr =~
		m/^(\p{Ll}(?:\p{Ll}|\s)+\s+)?($semiticprefix?$diacritics?\p{L}[^,]+|{[^,]+}),\s+([^,]+|{.+})$/;
		#m/^(\p{Ll}(?:\p{Ll}|\s)+)\s+([^,]+|{[^,]+}),\s+([^,]+|{.+})$/;
        $pre =~ s/\s+$// if $pre;
    }
    elsif ( $namestr =~ /\s/ and $namestr !~ /^{.+}$/ )
    {                              # Firstname <pre> Lastname
        ( $first, $pre, $last ) =
          $namestr =~ /^({.+}|(?:\p{Lu}\p{Ll}+\s*)+)\s+((?:\p{Ll}|\s)+)?(.+)$/;

        #$last =~ s/^{(.+)}$/$1/;
        $first =~ s/\s+$// if $first;

        #$first =~ s/^{(.+)}$/$1/ if $first;
        $pre =~ s/\s+$// if $pre;
    }
    else {    # Name alone
        $last = $namestr;

        $last =~ s/^{(.+)}$/$1/;
    }

        return {
            lastname   => $last,
            firstname  => $first,
            prefix     => $pre,
            suffix     => $suf
        }
} 

my $nr = 0;
my $previouskey;

while ( my $entry = new Text::BibTeX::Entry $bib) {
	$nr++;
	print "Problem with entry no $nr (following entry $previouskey) \n" 
		unless $entry->fieldlist;
    next unless $entry->parse_ok;
    if ( $entry->type eq "preamble" ) {
        $preamble .= $entry->value;
    }
    elsif ( $entry->type ne "string" ) {
        foreach my $f ( $entry->fieldlist ) {
			my $fname = $f;
			if ( $aliases{$f} ) {
				$fname = $aliases{$f};
			};
            $bibentries{ $entry->key }->{$fname} =
              decode_utf8( $entry->get($f) );
        }
        $bibentries{ $entry->key }->{entrytype} = $entry->type;
		$previouskey = $entry->key;
    }
}

my %seenname       = ();
my %seenuniquename = ();
my %seenauthoryear = ();
my @listofshorthands;
my %crossrefkeys = ();
my %localoptions = ();

# split list entries

my %numericalmonth = (
	'January' => 1,
	'February' => 2,
	'March' => 3,
	'April' => 4,
	'May' => 5,
	'June' => 6,
	'July' => 7,
	'August' => 8,
	'September' => 9,
	'October' => 10,
	'November' => 11,
	'December' => 12,
	'january' => 1,
	'february' => 2,
	'march' => 3,
	'april' => 4,
	'may' => 5,
	'june' => 6,
	'july' => 7,
	'august' => 8,
	'september' => 9,
	'october' => 10,
	'november' => 11,
	'december' => 12,
	'jan' => 1,
	'feb' => 2,
	'mar' => 3,
	'apr' => 4,
	'may' => 5,
	'jun' => 6,
	'jul' => 7,
	'aug' => 8,
	'sep' => 9,
	'oct' => 10,
	'nov' => 11,
	'dec' => 12
	);

foreach ( keys %bibentries ) {
    foreach my $ets (@entriestosplit) {
        if ( defined $bibentries{$_}->{$ets} ) {
            my $tmp = $bibentries{$_}->{$ets};

            # "and" within { } must be preserved: see biblatex manual §2.3.3
            #      (this can probably be optimized)
            foreach my $x ( $tmp =~ m/($RE{balanced}{-parens => '{}'})/g ) {
                ( my $xr = $x ) =~ s/\s+and\s+/_\x{ff08}_/g;
                $tmp =~ s/\Q$x/$xr/g;
            }
            my @y = split /\s+and\s+/, $tmp;
            my @z;
            foreach (@y) {
                s/_\x{ff08}_/ and /g;
                push @z, $_;
            }
            $bibentries{$_}->{$ets} = [@z];
        }
    } ;
	
	#Change month names to numbers
	if ($bibentries{$_}->{month}) {
		my $monthname = $bibentries{$_}->{month};
		if (exists $numericalmonth{$monthname}) {
			$bibentries{$_}->{month} = $numericalmonth{$monthname};
		}
	}

	# remove publisher for journal articles
	if ( $bibentries{$_}->{entrytype} eq 'article' and $bibentries{$_}->{publisher} ) {
		delete $bibentries{$_}->{publisher}
	}

	# remove url if identical to doi
	if ($bibentries{$_}->{doi} and $bibentries{$_}->{url} 
			and ($bibentries{$_}->{doi} eq $bibentries{$_}->{url})) {
		delete $bibentries{$_}->{url}
	}

	#Fix doi
	if ($bibentries{$_}->{doi}) {
		my $doi = $bibentries{$_}->{doi};
		if ( $doi =~ /^http/ ) {
			$doi =~ s|http://dx\.doi\.org/||;
		}
		$doi =~ s|\\_|_|g;
		$bibentries{$_}->{doi} = $doi
	}

    foreach my $field (@namefields) {
        next unless $bibentries{$_}->{$field};
        my @names = @{ $bibentries{$_}->{$field} };
        my @nameAoH;    # array of hashes
        foreach my $name (@names) {
            push @nameAoH, parsename( $_, $name );
        }
        $bibentries{$_}->{$field} = [@nameAoH];
    }
} ;

# Instantiate an XML::Writer object.  
my $outfile = $filename; 
$outfile =~ s/\.bib$//;
$outfile .= ".xml";
if ( -f $outfile ) {
	move($outfile, "$outfile.bak") or die "Can't move existing $outfile to $outfile.bak!: $!";
	print "Backuped existing $outfile as $outfile.bak\n";
};
my $output = new IO::File("> $outfile");
binmode($output, ':utf8');
my $writer = XML::Writer->new(OUTPUT => $output, DATA_MODE => 1, DATA_INDENT => 2, UNSAFE=>1);  

$writer->xmlDecl("UTF-8");  
$writer->raw('<?oxygen RNGSchema="file:/home/francois/dev/biber/biblatexml.rnc" type="compact"?>');

$writer->startTag("bib:entries", 'xmlns:bib'=>'http://ankabut.net/biblatexml');

my $count = 0;

for my $id ( sort keys %bibentries ) {
	$count++;
	my $entry = $bibentries{$id};
	if ($entry->{howpublished} and $entry->{type}) {
		$writer->startTag("bib:entry", 
			'id' => $id, 
			'entrytype' => $entry->{entrytype}, 
			'type' => $entry->{type},
			'howpublished' => $entry->{howpublished}); 
	}
	elsif ( $entry->{type} ) { 
		$writer->startTag('bib:entry',
			'id' => $id, 
			'entrytype' => $entry->{entrytype}, 
			'type' => $entry->{type}); 
	}
	elsif ( $entry->{howpublished} ) { 
		$writer->startTag('bib:entry',
			'id' => $id, 
			'entrytype' => $entry->{entrytype}, 
			'howpublished' => $entry->{howpublished}); 
	} else {
		$writer->startTag('bib:entry',
			'id' => $id, 
			'entrytype' => $entry->{entrytype}); 
	 };
	

	foreach my $field (@namefields) {
		if ($entry->{$field}) {
			my @nf = @{$entry->{$field}};
			if ( @nf and $nf[-1]->{"lastname"} and $nf[-1]->{"lastname"} eq "others" ) {
				$writer->startTag("bib:$field", "andothers" => "true");
				pop @nf;
			}
			else {
			$writer->startTag("bib:$field");
			};
			for my $i (0..$#nf) {
				$writer->startTag("bib:person"); # TODO add attribute gender if exists
				# if there is no firstname, we take the lastname as name string
				if (! $nf[$i]->{"firstname"}) {
					$writer->characters($nf[$i]->{"lastname"});
				} else {
					$writer->dataElement("bib:first", $nf[$i]->{"firstname"});
					$writer->dataElement("bib:prefix", $nf[$i]->{"prefix"}) if $nf[$i]->{"prefix"};
					$writer->dataElement("bib:last", $nf[$i]->{"lastname"});
					$writer->dataElement("bib:suffix", $nf[$i]->{"suffix"}) if $nf[$i]->{"suffix"};
				};
				$writer->endTag(); # person
			};
			$writer->endTag(); # $field
		}
	}; 
	foreach my $field (@titlefields) {
		if ($entry->{$field}) {
				$writer->startTag("bib:$field");
			$writer->characters($entry->{$field});
			$writer->endTag(); # $field
		}
	};
	
	foreach my $field (@listfields) {
		if ($entry->{$field}) {
			my @lf = @{$entry->{$field}};
			if ( $#lf > 0 ) {
				if ($lf[-1] eq "others" ) {
					$writer->startTag("bib:$field", "andothers"=>"true");
					pop @lf;
				} 
				else {
					$writer->startTag("bib:$field");
				};
				for my $i (0..$#lf) {
					$writer->startTag("bib:item");
					$writer->characters($lf[$i]);
					$writer->endTag(); #item
				};
				$writer->endTag(); #field
			}
			else {
				$writer->startTag("bib:$field");
				$writer->characters($entry->{$field}->[0]);
				$writer->endTag(); #field
			}
		}
	};

	foreach my $field (@otherfields) {
		if ($entry->{$field} and ($field ne 'pages')) {
			$writer->dataElement("bib:$field", $entry->{$field});
		}
		# we do it separately to get range and to fix pages -> pagetotal
		elsif ($field eq 'pages' and $entry->{pages}) {
			if ($entry->{entrytype} =~ /^(book|collection|proceedings|report|conference|unpublished|thesis|misc)/) {
				$writer->dataElement('bib:pagetotal', $entry->{pages})
			} 
			# 1-3, 7 => <pages>1-3, 7</pages>
			elsif ( $entry->{pages} =~ /[,;]/ ) { 
				$writer->startTag('bib:pages');
				$writer->dataElement('bib:list', $entry->{pages});
				$writer->endTag(); #pages
			}
			elsif ( $entry->{pages} =~ /(-|\x{2013})/ ) {
				my ($startpage, $endpage) = $entry->{pages} =~ /([^\s\-]+)[\s\-\x{2013}]+([^\s\-]+)/;
				$writer->startTag('bib:pages');
				$writer->dataElement('bib:start', $startpage);
				$writer->dataElement('bib:end', $endpage);
				$writer->endTag(); #pages
			}
			else {
				$writer->dataElement('bib:pages', $entry->{pages});
			}
		}
	}

	if ($entry->{'citeulike-article-id'}) {
		my $id = $entry->{'citeulike-article-id'};
		$writer->startTag('bib:library', "user"=>'FC');
		$writer->dataElement('bib:item', '', 'location'=>"citeulike", 'ref'=>$id);
		$writer->endTag(); #library
	}
	
	$writer->endTag(); #entry
};

$writer->endTag(); #entries

print "Processed $count entries\n";

