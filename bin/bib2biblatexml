#!/usr/bin/perl 
use strict ;
use warnings ;
use Carp ;
use open IO => ':encoding(utf8)' ;
binmode( STDOUT, ':utf8' ) ;
use Encode ;
use IO::File ;
use File::Copy ;
use XML::Writer ;

use Biber ;
use Biber::Constants ;
use Biber::Utils ;

use Getopt::Long qw/:config no_ignore_case/ ;

my $opts = {} ;
GetOptions(
    $opts,
    'help|h|?',
    'version|v',
    'inputencoding|i=s',
    'unicodebib|u!',
    'useprd|p!',
    'debug|D!',
    'stdout|c!',
#    'validate|V!', 
#    'schema|s=s', 
) ;

our $VERSION = '0.0.2' ;

die usage() if exists $opts->{'help'} ;

die version() if exists $opts->{'version'} ;

my $unicodebib = 0 ;

my $biber = Biber->new( { allentries => 1, unicodebbl => 1, 
        unicodebib => $opts->{unicodebib},
        biberdebug => $opts->{debug}, useprd => $opts->{useprd},
        inputencoding => $opts->{inputencoding} } ) ;

my $filename = $ARGV[0] or croak "No filename specified!";

unless ( -f $filename) { 

    unless ( -f "$filename.bib" ) {
        croak "There is no file $filename !\n" ;
    }

    $filename .= ".bib";
}

print version() ;

$biber->parse_bibtex($filename) ;

my %bibentries = $biber->bib ;
my $outfile;
my $output;

if ( $opts->{stdout} ) {
    $output = IO::Handle->new_from_fd('STDOUT', '>') ;
} else {
    $outfile = $filename ; 
    $outfile =~ s/\.bib$/.xml/ ;

    if ( -f $outfile ) {
        move($outfile, "$outfile.bak") or croak "Can't move existing $outfile to $outfile.bak!: $!" ;
        warn "Existing file $outfile backuped as $outfile.bak\n" ;
    } ;

    $output = IO::File->new($outfile, '>:utf8') ;

};

binmode($output, ':utf8') ;

my $writer = XML::Writer->new(OUTPUT => $output, DATA_MODE => 1, DATA_INDENT => 2, UNSAFE=>1) ;  

$writer->xmlDecl("UTF-8") ;  

$writer->startTag("bib:entries", 'xmlns:bib'=>'http://biblatex-biber.sourceforge.net/biblatexml',
    'xmlns:user'=>'http://localhost/biblatexml/user') ;

my $count = 0 ;

for my $citekey ( sort keys %bibentries ) {
  $count++ ;
  my $entry = $bibentries{$citekey} ;
    my @entryfields = keys %$entry ;
    my @specialfields = ( @NAMEFIELDS, @LISTFIELDS, @TITLEFIELDS ) ;
    my @standardfields = ( @RANGEFIELDS, @VERBATIMFIELDS, 
                           @LITERALFIELDS_BASE, @KEYFIELDS, @COMMASEP_FIELDS ) ;
    my @officialfields = ( @specialfields, @standardfields, 'entrytype', 'datatype' ) ;
    my @privatefields = array_minus( \@entryfields, \@officialfields ) ;

  if ($entry->{howpublished} and $entry->{type}) {
    $writer->startTag("bib:entry", 
      'id' => $citekey, 
      'entrytype' => $entry->{entrytype}, 
      'type' => $entry->{type},
      'howpublished' => $entry->{howpublished}) ; 
  }
  elsif ( $entry->{type} ) { 
    $writer->startTag('bib:entry',
      'id' => $citekey, 
      'entrytype' => $entry->{entrytype}, 
      'type' => $entry->{type}) ; 
  }
  elsif ( $entry->{howpublished} ) { 
    $writer->startTag('bib:entry',
      'id' => $citekey, 
      'entrytype' => $entry->{entrytype}, 
      'howpublished' => $entry->{howpublished}) ; 
  } else {
    $writer->startTag('bib:entry',
      'id' => $citekey, 
      'entrytype' => $entry->{entrytype}) ; 
    } ;
  

  foreach my $field (@NAMEFIELDS) {
    if ($entry->{$field}) {
      my @nf = @{$entry->{$field}} ;
      if ( @nf and $nf[-1]->{"lastname"} and $nf[-1]->{"lastname"} eq "others" ) {
        $writer->startTag("bib:$field", "andothers" => "true") ;
        pop @nf ;
      }
      else {
      $writer->startTag("bib:$field") ;
      } ;
      for my $i (0..$#nf) {
        $writer->startTag("bib:person") ; # TODO add attribute gender if exists
        # if there is no firstname, we take the lastname as name string
        if (! $nf[$i]->{"firstname"}) {
          $writer->characters($nf[$i]->{"lastname"}) ;
        } else {
          $writer->dataElement("bib:first", $nf[$i]->{"firstname"}) ;
          $writer->dataElement("bib:prefix", $nf[$i]->{"prefix"}) if $nf[$i]->{"prefix"} ;
          $writer->dataElement("bib:last", $nf[$i]->{"lastname"}) ;
          $writer->dataElement("bib:suffix", $nf[$i]->{"suffix"}) if $nf[$i]->{"suffix"} ;
        } ;
        $writer->endTag() ; # person
      } ;
      $writer->endTag() ; # $field
    }
  } ; 
  foreach my $field (@TITLEFIELDS) {
    if ($entry->{$field}) {
        $writer->startTag("bib:$field") ;
      $writer->characters($entry->{$field}) ;
      $writer->endTag() ; # $field
    }
  } ;
  
  foreach my $field (@LISTFIELDS) {
    if ($entry->{$field}) {
      
            my @lf = @{$entry->{$field}} ;
            
            my $afield = $field ;

            if ( $ALIASES{$field} ) {
                $afield = $ALIASES{$field} 
            } ;
      
            if ( $#lf > 0 ) {
        if ($lf[-1] eq "others" ) {
          $writer->startTag("bib:$afield", "andothers"=>"true") ;
          pop @lf ;
        } 
        else {
          $writer->startTag("bib:$afield") ;
        } ;
        for my $i (0..$#lf) {
          $writer->startTag("bib:item") ;
          $writer->characters($lf[$i]) ;
          $writer->endTag() ; #item
        } ;
        $writer->endTag() ; #field
      }
      else {
        $writer->startTag("bib:$afield") ;
        $writer->characters($entry->{$afield}->[0]) ;
        $writer->endTag() ; #field
      }
    }
  } ;

  foreach my $field (array_minus( \@standardfields, ['type', 'howpublished'] )) {
        if ($entry->{$field}) {
            if ( $field eq 'month' && $entry->{month} =~ m/[a-z]/i) {
                
                my $monthnumber = $NUMERICALMONTH{$entry->{month}} || $entry->{month};
  
                $writer->dataElement("bib:month", $monthnumber) ;
            }
            elsif ($field eq 'pages') {
                if ($entry->{entrytype} =~ /^(book|collection|proceedings|report|conference|unpublished|thesis|misc)/) {
                    $writer->dataElement('bib:pagetotal', $entry->{pages})
                } 
                # 1-3, 7 => <pages>1-3, 7</pages>
                elsif ( $entry->{pages} =~ /[, ;]/ ) { 
                    $writer->startTag('bib:pages') ;
                    $writer->dataElement('bib:list', $entry->{pages}) ;
                    $writer->endTag() ; #pages
                }
                elsif ( $entry->{pages} =~ /(-|\x{2013})/ ) {
                    my ($startpage, $endpage) = $entry->{pages} =~ /([^\s\-]+)[\s\-\x{2013}]+([^\s\-]+)/ ;
                    $writer->startTag('bib:pages') ;
                    $writer->dataElement('bib:start', $startpage) ;
                    $writer->dataElement('bib:end', $endpage) ;
                    $writer->endTag() ; #pages
                }
                else {
                    $writer->dataElement('bib:pages', $entry->{pages}) ;
                }
            }
        else {

                my $afield = $field;
            
                if ( $ALIASES{$field} ) {
                    $afield = $ALIASES{$field}
                }
      
            $writer->dataElement("bib:$afield", $entry->{$field}) ;
          }
        # we do it separately to get range and to fix pages -> pagetotal
        }
  }

    if ($#privatefields > 0) {

        $writer->startTag('bib:private', "user"=>$ENV{USER}) ;

        foreach my $field (@privatefields) {
            # TODO add more like this, e.g. Zotero, BibSonomy, etc.
            if ($field eq 'citeulike-article-id') {
                my $id = $entry->{'citeulike-article-id'} ;
                $writer->startTag('bib:library') ;
                $writer->dataElement('bib:item', '', 'location'=>"citeulike", 'ref'=>$id) ;
                $writer->endTag() ; #library
            }
            else {
                $writer->dataElement("user:$field", $entry->{$field}) ;
            }
        }
        $writer->endTag() ; #user
    }
  $writer->endTag() ; #entry
} ;

$writer->endTag() ; #entries

unless ($opts->{stdout}) {
    print "Converted $count entries\n" ;
    print "Output written to $outfile\n\n" ;
    close $output ;
}


#if ( $opts->{validate} ) {
#
#    require XML::LibXML ;
#    
#    my $xmldoc = XML::LibXML->new->parse_file($outfile) ;
#    
#    my $schema = "biblatexml.rng" ;
#
#    if ( $opts->{schema} ) { 
#        $schema = $opts->{schema}
#    } ;
#
#    my $rngschema = XML::LibXML::RelaxNG->new( location => $schema ) ;
#    
#    my $validation = eval { $rngschema->validate($xmldoc) ; } ; 
#    
#    unless ($validation) {
#        carp "!!!\nThe file $outfile does not validate against the BibLaTeXML RelaxNG schema\n!!!\n$@"
#    } 
#} 

sub version {
    my $me = "bib2biblatexml" ;    #basename($0);

    qq[
$me Version: $VERSION
    Warning: This is still alpha quality. 
    You are advised to wait for a stable release before definitively 
    switching to the BibLaTeXML format!
      \n]
}

sub usage {
    my $me = "bib2biblatexml" ;    #basename($0);

    qq[
Usage:  $me <file>.bib
     Creates <file>.xml

Options:
  --help|-h              Show this help message.
  --version|-v           Display version number.
  --inputencoding|-i [encoding] 
                         Input file uses legacy encoding.
  --unicodebib|u!        Assume bib file is UTF-8 and skip latex_decode.
     \n]
}

=pod

=head1 NAME

C<bib2biblatexml> - converts BibTeX files to BibLaTeXML

=head1 VERSION

Version 0.0.1

NOTE: This is still alpha quality. Use at your own risk ;)

=head1 SYNOPSIS

biblatexml file.bib 
    (outputs file.xml)

=head1 DESCRIPTION

TBW

=head1 AUTHOR

François Charette, C<< <firmicus at gmx.net> >>

=head1 BUGS

Please report any bugs or feature requests on our sourceforge tracker at
L<https://sourceforge.net/tracker2/?func=browse&group_id=228270>. 

=head1 COPYRIGHT & LICENSE

Copyright 2009 François Charette, all rights reserved.

This program is free software ; you can redistribute it and/or modify it
under the same terms as Perl itself.

=cut

# vim: set tabstop=2 shiftwidth=2 expandtab:
