#!/usr/bin/perl 
use strict ;
use warnings ;
# no warnings 'utf8' ;
use Carp ;
use open IO => ':encoding(utf8)' ;
binmode( STDOUT, ':utf8' ) ;
use Encode ;
use IO::File ;
use File::Copy ;
use XML::Writer ;

#This should be removed in the official distribution:
#use FindBin ;
#use lib "$FindBin::Bin/../lib" ;

use Biber ;
use Biber::Constants ;
use Biber::Utils ;

use Getopt::Long qw/:config no_ignore_case/ ;

my $opts = {} ;
GetOptions(
    $opts,
    'help|h|?',
    'version|v',
    'inputencoding|i=s',
    'useprd|p!',
    'debug|D!',
#    'validate|V!', 
#    'schema|s=s', 
) ;

our $VERSION = '0.0.1' ;

die usage() if exists $opts->{'help'} ;

die version() if exists $opts->{'version'} ;

my %aliases = ( 
	'address' => 'location',
	'school'  => 'institution',
	'annote'  => 'annotation',
	'key'     => 'sortkey'
) ;

my %numericalmonth = (
	'January' => 1,
	'February' => 2,
	'March' => 3,
	'April' => 4,
	'May' => 5,
	'June' => 6,
	'July' => 7,
	'August' => 8,
	'September' => 9,
	'October' => 10,
	'November' => 11,
	'December' => 12,
	'january' => 1,
	'february' => 2,
	'march' => 3,
	'april' => 4,
	'may' => 5,
	'june' => 6,
	'july' => 7,
	'august' => 8,
	'september' => 9,
	'october' => 10,
	'november' => 11,
	'december' => 12,
	'jan' => 1,
	'feb' => 2,
	'mar' => 3,
	'apr' => 4,
	'may' => 5,
	'jun' => 6,
	'jul' => 7,
	'aug' => 8,
	'sep' => 9,
	'oct' => 10,
	'nov' => 11,
	'dec' => 12
	) ;

my @TITLEFIELDS = 
    qw/ title 
    subtitle
	titleaddon
	shorttitle
	sorttitle
	indextitle
	indexsorttitle
	origtitle
	issuetitle
	issuesubtitle
	maintitle
	mainsubtitle
	maintitleaddon
	booktitle
	booksubtitle
	booktitleaddon
	journal
	journaltitle
	journalsubtitle
	reprinttitle /;

my $biber = Biber->new( { allentries => 1, unicodebbl => 1, 
        biberdebug => $opts->{debug}, useprd => $opts->{useprd},
        inputencoding => $opts->{inputencoding} } ) ;

my $filename = $ARGV[0] ;

unless ( -f $filename) { 

    unless ( -f "$filename.bib" ) {
        croak "There is no file $filename !\n" ;
    }

    $filename .= ".bib";
}

print version() ;

$biber->parse_bibtex($filename) ;

unlink "$filename.utf8" or carp "Cannot delete $filename.utf8" ;

my %bibentries = $biber->bib ;

my $outfile = $filename ; 
$outfile =~ s/\.bib$/.xml/ ;

if ( -f $outfile ) {
	move($outfile, "$outfile.bak") or croak "Can't move existing $outfile to $outfile.bak!: $!" ;
	warn "Existing file $outfile backuped as $outfile.bak\n" ;
} ;

my $output = new IO::File("> $outfile") ;

binmode($output, ':utf8') ;

my $writer = XML::Writer->new(OUTPUT => $output, DATA_MODE => 1, DATA_INDENT => 2, UNSAFE=>1) ;  

$writer->xmlDecl("UTF-8") ;  

$writer->startTag("bib:entries", 'xmlns:bib'=>'http://biblatex-biber.sourceforge.net/biblatexml') ;

my $count = 0 ;

for my $citekey ( sort keys %bibentries ) {
	$count++ ;
	my $entry = $bibentries{$citekey} ;
    my @entryfields = keys %$entry ;
    my $specialfields = [ @NAMEFIELDS, @LISTFIELDS, @TITLEFIELDS, 'entrytype', 'howpublished', 'type', 'datatype' ] ;
    my @OTHERFIELDS = array_minus( \@entryfields, $specialfields ) ;

	if ($entry->{howpublished} and $entry->{type}) {
		$writer->startTag("bib:entry", 
			'id' => $citekey, 
			'entrytype' => $entry->{entrytype}, 
			'type' => $entry->{type},
			'howpublished' => $entry->{howpublished}) ; 
	}
	elsif ( $entry->{type} ) { 
		$writer->startTag('bib:entry',
			'id' => $citekey, 
			'entrytype' => $entry->{entrytype}, 
			'type' => $entry->{type}) ; 
	}
	elsif ( $entry->{howpublished} ) { 
		$writer->startTag('bib:entry',
			'id' => $citekey, 
			'entrytype' => $entry->{entrytype}, 
			'howpublished' => $entry->{howpublished}) ; 
	} else {
		$writer->startTag('bib:entry',
			'id' => $citekey, 
			'entrytype' => $entry->{entrytype}) ; 
    } ;
	

	foreach my $field (@NAMEFIELDS) {
		if ($entry->{$field}) {
			my @nf = @{$entry->{$field}} ;
			if ( @nf and $nf[-1]->{"lastname"} and $nf[-1]->{"lastname"} eq "others" ) {
				$writer->startTag("bib:$field", "andothers" => "true") ;
				pop @nf ;
			}
			else {
			$writer->startTag("bib:$field") ;
			} ;
			for my $i (0..$#nf) {
				$writer->startTag("bib:person") ; # TODO add attribute gender if exists
				# if there is no firstname, we take the lastname as name string
				if (! $nf[$i]->{"firstname"}) {
					$writer->characters($nf[$i]->{"lastname"}) ;
				} else {
					$writer->dataElement("bib:first", $nf[$i]->{"firstname"}) ;
					$writer->dataElement("bib:prefix", $nf[$i]->{"prefix"}) if $nf[$i]->{"prefix"} ;
					$writer->dataElement("bib:last", $nf[$i]->{"lastname"}) ;
					$writer->dataElement("bib:suffix", $nf[$i]->{"suffix"}) if $nf[$i]->{"suffix"} ;
				} ;
				$writer->endTag() ; # person
			} ;
			$writer->endTag() ; # $field
		}
	} ; 
	foreach my $field (@TITLEFIELDS) {
		if ($entry->{$field}) {
				$writer->startTag("bib:$field") ;
			$writer->characters($entry->{$field}) ;
			$writer->endTag() ; # $field
		}
	} ;
	
	foreach my $field (@LISTFIELDS) {
		if ($entry->{$field}) {
			
            my @lf = @{$entry->{$field}} ;
            
            my $afield = $field ;

            if ( $aliases{$field} ) {
                $afield = $aliases{$field} 
            } ;
			
            if ( $#lf > 0 ) {
				if ($lf[-1] eq "others" ) {
					$writer->startTag("bib:$afield", "andothers"=>"true") ;
					pop @lf ;
				} 
				else {
					$writer->startTag("bib:$afield") ;
				} ;
				for my $i (0..$#lf) {
					$writer->startTag("bib:item") ;
					$writer->characters($lf[$i]) ;
					$writer->endTag() ; #item
				} ;
				$writer->endTag() ; #field
			}
			else {
				$writer->startTag("bib:$afield") ;
				$writer->characters($entry->{$afield}->[0]) ;
				$writer->endTag() ; #field
			}
		}
	} ;

	foreach my $field (@OTHERFIELDS) {
        if ( $field eq 'month' ) {
            
            my $monthnumber = $numericalmonth{$entry->{month}} || $entry->{month};

			$writer->dataElement("bib:month", $monthnumber) ;
        }
		elsif ($field eq 'pages') {
			if ($entry->{entrytype} =~ /^(book|collection|proceedings|report|conference|unpublished|thesis|misc)/) {
				$writer->dataElement('bib:pagetotal', $entry->{pages})
			} 
			# 1-3, 7 => <pages>1-3, 7</pages>
			elsif ( $entry->{pages} =~ /[, ;]/ ) { 
				$writer->startTag('bib:pages') ;
				$writer->dataElement('bib:list', $entry->{pages}) ;
				$writer->endTag() ; #pages
			}
			elsif ( $entry->{pages} =~ /(-|\x{2013})/ ) {
				my ($startpage, $endpage) = $entry->{pages} =~ /([^\s\-]+)[\s\-\x{2013}]+([^\s\-]+)/ ;
				$writer->startTag('bib:pages') ;
				$writer->dataElement('bib:start', $startpage) ;
				$writer->dataElement('bib:end', $endpage) ;
				$writer->endTag() ; #pages
			}
			else {
				$writer->dataElement('bib:pages', $entry->{pages}) ;
			}
		}
        else {

            my $afield = $field;
            
            if ( $aliases{$field} ) {
                $afield = $aliases{$field}
            }
			
			$writer->dataElement("bib:$afield", $entry->{$field}) ;
		}
		# we do it separately to get range and to fix pages -> pagetotal
	}

    # TODO add more like this, e.g. Zotero, BibSonomy, etc.
	if ($entry->{'citeulike-article-id'}) {
		my $id = $entry->{'citeulike-article-id'} ;
		$writer->startTag('bib:user', "id"=>$ENV{USER}) ;
        $writer->startTag('bib:library') ;
		$writer->dataElement('bib:item', '', 'location'=>"citeulike", 'ref'=>$id) ;
		$writer->endTag() ; #library
		$writer->endTag() ; #user
	}
	
	$writer->endTag() ; #entry
} ;

$writer->endTag() ; #entries

print "Converted $count entries\n" ;
print "Output written to $outfile\n\n" ;

close $output ;

#if ( $opts->{validate} ) {
#
#    require XML::LibXML ;
#    
#    my $xmldoc = XML::LibXML->new->parse_file($outfile) ;
#    
#    my $schema = "biblatexml.rng" ;
#
#    if ( $opts->{schema} ) { 
#        $schema = $opts->{schema}
#    } ;
#
#    my $rngschema = XML::LibXML::RelaxNG->new( location => $schema ) ;
#    
#    my $validation = eval { $rngschema->validate($xmldoc) ; } ; 
#    
#    unless ($validation) {
#        carp "!!!\nThe file $outfile does not validate against the BibLaTeXML RelaxNG schema\n!!!\n$@"
#    } 
#} 

sub version {
    my $me = "bib2biblatexml" ;    #basename($0);

    qq[
$me Version: $VERSION
    Warning: This is still alpha quality. 
    You are advised to wait for a stable release before definitively 
    switching to the BibLaTeXML format!
      \n]
}

sub usage {
    my $me = "bib2biblatexml" ;    #basename($0);

    qq[
Usage:  $me <file>.bib
     Creates <file>.xml

Options:
  --help|-h              Show this help message.
  --version|-v           Display version number.
  --inputencoding|-i [encoding] 
                         Input file uses legacy encoding 
     \n]
}

=pod

=head1 NAME

C<bib2biblatexml> - converts BibTeX files to BibLaTeXML

=head1 VERSION

Version 0.0.1

NOTE: This is still alpha quality. Use at your own risk ;)

=head1 SYNOPSIS

biblatexml file.bib 
    (outputs file.xml)

=head1 DESCRIPTION

TBW

=head1 AUTHOR

François Charette, C<< <firmicus at gmx.net> >>

=head1 BUGS

Please report any bugs or feature requests on our sourceforge tracker at
L<https://sourceforge.net/tracker2/?func=browse&group_id=228270>. 

=head1 COPYRIGHT & LICENSE

Copyright 2009 François Charette, all rights reserved.

This program is free software ; you can redistribute it and/or modify it
under the same terms as Perl itself.

=cut

# vim: set tabstop=4 shiftwidth=4:
