#!/usr/bin/perl
use strict;
use warnings;
use Carp;
use open IO => ':encoding(utf8)';
binmode( STDOUT, ':utf8' );
use Encode;
use IO::File;
use File::Copy;
use XML::Writer;

use Biber;
use Biber::Constants;
use Biber::Utils;

use Log::Log4perl qw(:easy);
Log::Log4perl->easy_init($ERROR);

use Getopt::Long qw/:config no_ignore_case/;

my $opts = {};
GetOptions(
    $opts,
    'help|h|?',
    'version|v',
    'inputencoding|i=s',
    'unicodebib|u!',
    'useprd|p!',
    'debug|D!',
    'stdout|c!',
    'filter|f!',
    'validate|V!',
    'schema|s=s',
);

our $VERSION = '0.0.4';

die usage() if exists $opts->{'help'};

die version() if exists $opts->{'version'};

my $unicodebib = 0;

my $biber = Biber->new(
    {
        allentries    => 1,
        unicodebbl    => 1,
        unicodebib    => $opts->{unicodebib},
        biberdebug    => $opts->{debug},
        useprd        => $opts->{useprd},
        inputencoding => $opts->{inputencoding}
    }
);

my $filename;

if ( $opts->{filter} ) {
    $filename = IO::Handle->new_from_fd( 'STDIN', '<' );
}
else {
    $filename = $ARGV[0] or croak "No filename specified!";
    unless ( -f $filename ) {

        unless ( -f "$filename.bib" ) {
            croak "There is no file $filename !\n";
        }

        $filename .= ".bib";
    }
}

print version();

$biber->parse_bibtex($filename);

my $bibentries = $biber->bib;
my $outfile;
my $output;

if ( $opts->{filter} or $opts->{stdout} ) {
    $output = IO::Handle->new_from_fd( 'STDOUT', '>' );
}
else {
    $outfile = $filename;
    $outfile =~ s/(?:\.bib)?$/.xml/;

    if ( -f $outfile ) {
        move( $outfile, "$outfile.bak" )
          or croak "Can't move existing $outfile to $outfile.bak!: $!";
        warn "Existing file $outfile backuped as $outfile.bak\n";
    }

    $output = IO::File->new( $outfile, '>:utf8' );

}

binmode( $output, ':utf8' );

my $writer = XML::Writer->new(
    OUTPUT      => $output,
    DATA_MODE   => 1,
    DATA_INDENT => 2,
    UNSAFE      => 1
);

$writer->xmlDecl("UTF-8");

$writer->startTag(
    "bib:entries",
    'xmlns:bib'  => 'http://biblatex-biber.sourceforge.net/biblatexml',
    'xmlns:user' => 'http://localhost/biblatexml/user'
);

my $count = 0;

for my $citekey ( $bibentries->entries_keys ) {
    $count++;
    my $entry          = $bibentries->entry($citekey);
    my @entryfields    = $entry->fields;
    my @specialfields  = ( @NAMEFIELDS, @LISTFIELDS, @TITLEFIELDS );
    my @standardfields = (
        @RANGEFIELDS, @DATERANGEFIELDS, @DATECOMPONENTFIELDS,
        @VERBATIMFIELDS, @LITERALFIELDS_BASE,
        @KEYFIELDS,   @COMMASEP_FIELDS
    );
    my @officialfields =
      ( @specialfields, @standardfields, 'entrytype', 'datatype' );
    my @privatefields = reduce_array( \@entryfields, \@officialfields );

    my %attrs; # hash for storing attributes

    $attrs{entrytype} = $entry->get_field('entrytype');
    $attrs{id}        = $citekey;

    if ( $entry->get_field('howpublished') ) {
        $attrs{howpublished} = $entry->get_field('howpublished')
    }
    if ( $entry->get_field('type') ) {
        $attrs{type} = $entry->get_field('type')
    }

    # we assume phdthesis when type is omitted
    if ($entry->get_field('entrytype') eq 'thesis' and ! $entry->get_field('type')) {
        $attrs{type} = 'phdthesis'
    }

    $writer->startTag( 'bib:entry', %attrs );


    foreach my $field (@NAMEFIELDS) {
        if ( $entry->get_field($field) ) {

            my $afield = $field;
            if ($field =~ /^(editor|name)(a|b|c)/) {
                $afield =~ s/^(editor|name)(.)/$1\u$2/;
            }
            my %attrs ; # hash for storing attributes

            my @nf = @{ $entry->get_field($field) };

            if (    @nf
                and $nf[-1]->{"lastname"}
                and $nf[-1]->{"lastname"} eq "others" )
            {
                $attrs{andothers} = "true";
                pop @nf;
            }

            if ($entry->get_field("${field}type")) {
                $attrs{type} = $entry->get_field("${field}type")
            }
            if ($entry->get_field("${field}class")) {
                $attrs{class} = $entry->get_field("${field}class")
            }

            $writer->startTag("bib:$afield", %attrs);

            for my $i ( 0 .. $#nf ) {
                $writer->startTag("bib:person")
                  ;    # TODO add attribute gender if exists
                 # if there is no firstname, we take the lastname as name string
                if ( !$nf[$i]->{"firstname"} ) {
                    $writer->characters( $nf[$i]->{"lastname"} );
                }
                else {
                    $writer->dataElement( "bib:first", $nf[$i]->{"firstname"} );
                    $writer->dataElement( "bib:prefix", $nf[$i]->{"prefix"} )
                      if $nf[$i]->{"prefix"};
                    $writer->dataElement( "bib:last",   $nf[$i]->{"lastname"} );
                    $writer->dataElement( "bib:suffix", $nf[$i]->{"suffix"} )
                      if $nf[$i]->{"suffix"};
                }
                $writer->endTag();    # person
            }
            $writer->endTag();        # $field
        }
    }
    foreach my $field (@TITLEFIELDS) {
        if ( $entry->get_field($field) ) {
            $writer->startTag("bib:$field");
            $writer->characters( $entry->get_field($field) );
            $writer->endTag();        # $field
        }
    }

    foreach my $field (@LISTFIELDS) {
        if ( $entry->get_field($field) ) {

            my @lf = @{ $entry->get_field($field) };

            my $afield = $field;

            if ( $ALIASES{$field} ) {
                $afield = $ALIASES{$field};
            }
            if ($afield =~ /^list[a-f]/) {
                $afield =~ s/^list([a-f])/list\u$1/
            }

            if ( $#lf > 0 ) {
                if ( $lf[-1] eq "others" ) {
                    $writer->startTag( "bib:$afield", "andothers" => "true" );
                    pop @lf;
                }
                else {
                    $writer->startTag("bib:$afield");
                }
                for my $i ( 0 .. $#lf ) {
                    $writer->startTag("bib:item");
                    my $content = $lf[$i];
                    if ($field eq 'language') {
                        $content =~ s/^lang//;
                    }
                    $writer->characters( $content );
                    $writer->endTag();    #item
                }
                $writer->endTag();        #field
            }
            else {
                $writer->startTag("bib:$afield");
                $writer->characters( $entry->get_field($afield)->[0] );
                $writer->endTag();        #field
            }
        }
    }

    # handle date fields with slash separator
    foreach my $datefield (@DATERANGEFIELDS) {
        if ( $entry->get_field($datefield) ) {
            $writer->startTag("bib:$datefield");
            my $datestring = $entry->get_field($datefield);
            if ($datestring =~ m|/|) {
                my @datelist = split('/', $datestring);
                if ($#datelist == 1) {
                    $writer->dataElement("bib:start", $datelist[0]);
                    $writer->dataElement("bib:end",   $datelist[1]);
                }
                else {
                    $writer->startTag("bib:list");
                    foreach my $dateitem (@datelist) {
                        $writer->dataElement("bib:item", $dateitem)
                    }
                    $writer->endTag(); # bib:list
                }
            }
            else {
                $writer->characters($datestring)
            }
            $writer->endTag(); # $datefield
        }
    }


    ## convert year month day to "date"
    if ( $entry->get_field('year') && ! $entry->get_field('date') ) {
        my $datestring = $entry->get_field('year');
        if ( $entry->get_field('month') && $entry->get_field('month') =~ m/[a-z]/i ) {
            my $monthnumber = $NUMERICALMONTH{ $entry->get_field('month') }
              || $entry->get_field('month');
            $datestring .= "-" . sprintf("%02d", $monthnumber);
            if ($entry->get_field('day')) {
                $datestring .= "-" . sprintf("%02d", $entry->get_field('day'));
            }
        }
        $writer->dataElement( "bib:date", $datestring );
    }

    foreach my $field (
        reduce_array(
            \@standardfields, [ @DATERANGEFIELDS, @DATECOMPONENTFIELDS,
            'type', 'howpublished', 'eprinttype',
            'editoratype', 'editorbtype', 'editorctype',
            'editoraclass', 'editorbclass', 'editorcclass' ]
        )
      )
    {
        if ( $entry->get_field($field) ) {
            if ( $field eq 'pages' ) {
                if ( $entry->get_field('entrytype') =~
                     /^(book|collection|proceedings|report|conference|unpublished|thesis|misc)/
                   )
                {
                    $writer->dataElement( 'bib:pagetotal', $entry->get_field('pages') );
                }

                # 1-3, 7 => <pages>1-3, 7</pages>
                elsif ( $entry->get_field('pages') =~ /[, ;]/ ) {
                    $writer->startTag('bib:pages');
                    $writer->dataElement( 'bib:list', $entry->get_field('pages') );
                    $writer->endTag();    #pages
                }
                elsif ( $entry->get_field('pages') =~ /(-|\x{2013})/ ) {
                    my ( $startpage, $endpage ) =
                      $entry->get_field('pages') =~ /([^\s\-]+)[\s\-\x{2013}]+([^\s\-]+)/;
                    $writer->startTag('bib:pages');
                    $writer->dataElement( 'bib:start', $startpage );
                    $writer->dataElement( 'bib:end',   $endpage );
                    $writer->endTag();    #pages
                }
                else {
                    $writer->dataElement( 'bib:pages', $entry->get_field('pages') );
                }
            }
            # fields with attribute "type" (right now only "eprint")
            elsif ( $entry->get_field("${field}type") ) {
                $writer->dataElement(
                    "bib:$field",
                    $entry->get_field($field),
                    type => $entry->get_field("${field}type")
                )
            }
            else {

                my $afield = $field;

                if ( $ALIASES{$field} ) {
                    $afield = $ALIASES{$field};
                }
                $writer->dataElement( "bib:$afield", $entry->get_field($field) );
            }

            # we do it separately to get range and to fix pages -> pagetotal
        }
    }

    if ( $#privatefields > 0 ) {

        $writer->startTag( 'bib:private', "user" => $ENV{USER} );

        foreach my $field (@privatefields) {

            # TODO add more like this, e.g. Zotero, BibSonomy, etc.
            if ( $field eq 'citeulike-article-id' ) {
                my $id = $entry->get_field('citeulike-article-id');
                $writer->startTag('bib:library');
                $writer->dataElement(
                    'bib:item', '',
                    'location' => "citeulike",
                    'ref'      => $id
                );
                $writer->endTag();    #library
            }
            else {
                $writer->dataElement( "user:$field", $entry->get_field($field) );
            }
        }
        $writer->endTag();            #user
    }
    $writer->endTag();                #entry
}

$writer->endTag() unless $opts->{filter};    #entries

unless ( $opts->{filter} or $opts->{stdout} ) {
    print "Converted $count entries\n";
    print "Output written to $outfile\n\n";
}

close $output;

if ( $opts->{validate} ) {
    require XML::LibXML;
    # Set up XML parser
    my $xmlparser = XML::LibXML->new();
    $xmlparser->line_numbers(1); # line numbers for more informative errors

    # Set up schema
    my $xmlschema;
    #my $path = first { -f File::Spec->catfile($_, 'Biber', 'biblatexml.rng') } @INC;
    (undef, my $biber_path, undef) = File::Spec->splitpath( $INC{"Biber.pm"} );
    my $rng = File::Spec->catfile($biber_path, 'Biber', 'biblatexml.rng');

    if (-f $rng) {
        $xmlschema = XML::LibXML::RelaxNG->new( location => $rng )
    } else {
        print "Cannot find XML::LibXML::RelaxNG schema at $rng. Skipping validation:\n$!\n";
    }

    # basic parse and XInclude processing
    my $xp = $xmlparser->parse_file($outfile);

    # XPath context
    my $xpc = XML::LibXML::XPathContext->new($xp);
    $xpc->registerNs('bib', 'http://biblatex-biber.sourceforge.net/biblatexml');

    # Validate against schema. Dies if it fails.
    if ($xmlschema) {
        eval { $xmlschema->validate($xp) };
        if (ref($@)) {
            print "BibLaTeXML file \"$outfile\" FAILED TO VALIDATE\nwith schema $rng\n$@\n";
        }
        elsif ($@) {
            print "BibLaTeXML file \"$outfile\" FAILED TO VALIDATE\nwith schema $rng\n$@\n";
        }
        else {
            print "BibLaTeXML file \"$outfile\" validates\n";
        }
    }
}

sub version {
    my $me = "bib2biblatexml";    #basename($0);

    qq[
$me Version: $VERSION
    Warning: This is still alpha quality.
    You are advised to wait for a stable release before definitively
    switching to the BibLaTeXML format!
      \n]
}

sub usage {
    my $me = "bib2biblatexml";    #basename($0);

    qq[
Usage:  $me <file>.bib
     Creates <file>.xml

Options:
  --help|-h              Show this help message.
  --version|-v           Display version number.
  --inputencoding|-i [encoding]
                         Input file uses legacy encoding.
  --unicodebib|u!        Assume bib file is UTF-8 and skip latex_decode.
  \n]
  #--validate|-V!         Validate the resulting XML file (>> UNRELIABLE! <<)
  #--schema|-s <file>     Use Relax-NG schema <file> for validation TODO?
}

=pod

=encoding utf8

=head1 NAME

C<bib2biblatexml> - converts BibTeX files to BibLaTeXML

=head1 VERSION

Version 0.0.4

NOTE: This is still alpha quality. Use at your own risk ;)

=head1 SYNOPSIS

biblatexml file.bib
    (outputs file.xml)

=head1 DESCRIPTION

TBW

=head1 AUTHOR

François Charette, C<< <firmicus at gmx.net> >>

=head1 BUGS

Please report any bugs or feature requests on our sourceforge tracker at
L<https://sourceforge.net/tracker2/?func=browse&group_id=228270>.

=head1 COPYRIGHT & LICENSE

Copyright 2009-2010 François Charette, all rights reserved.

This program is free software ; you can redistribute it and/or modify it
under the same terms as Perl itself.

=cut

# vim: set tabstop=4 shiftwidth=4 expandtab:
