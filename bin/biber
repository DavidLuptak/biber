#!/usr/bin/perl 
#===============================================================================
#
#         FILE:  biber
#
#        USAGE:  biber [options] auxfile
#                Type biber -h or --help for details
#
#  DESCRIPTION:  A BibTeX replacement for users of biblatex
#
#               The biblatex package by Philipp Lehman is likely to become
#               the definitive citation management tool for LaTeX users.
#               Biblatex relies on the venerable bibtex program only for
#               sorting and generating a very generic bbl file without any
#               formatting instruction.  Everything else is taken care of by
#               biblatex. With Biber it is (will be) no longer necessary to
#               rely on BibTeX. For maximal portability, the current version
#               includes a BibTeX parser with a Parse::RecDescent grammar, but
#               if available it will use the faster Text::BibTeX module. The
#               objective of the first development phase is to have a robust
#               and reliable emulation of BibTeX with the biblatex.bst style
#               file. In other words, given the same aux file as input, to
#               output an identical bbl file as BibTeX would.
#               
#               This version also introduces support for a new XML format
#               tailored specifically for biblatex data: BibLaTeXML. It owes
#               its inspiration partly to the BibTeXML format, but it is far
#               more complex. A complete RelaXNG schema is provided, as well 
#               as a tool for converting bib files to biblatexml. To parse 
#               BibLaTeXML databases the perl module XML::LibXML is required.
#               
#               The advantages of no longer being dependent upon BibTeX are
#               obvious: full Unicode support, no memory limitations,
#               extensibility, etc. In the future, support for communication 
#               with databases (like Berkeley DB, SQLite, MySQL, PostgreSQL, eXisT) 
#               or remote resources via network protocols (such as SRU).
#
#               TODO
#               * Make it more modular and (perhaps) with OO interface ?
#               * plugin facility
#               * add option --inputencoding <latin1> (only utf8 supported as of now)
#               * make available as par archive for maximal portability ?
#               * SEE also TODO's inserted below
#
# REQUIREMENTS:  Text::BibTeX or Parse::RecDescent; Regexp::Common; 
#                  LaTeX::Decode (included)
#         BUGS:  No doubt many... 
#       AUTHOR:  François Charette <firmicus ατ gmx δοτ net>
#      VERSION:  0.3
#      CREATED:  29/02/08 12:43:03 CET
#===============================================================================

use strict;
use warnings;
no warnings 'utf8';
use Carp;
use Getopt::Long qw/:config no_ignore_case/;
my $opts = {};
GetOptions(
    $opts,
    'fastsort|f!',
    'mincrossrefs|m=s',
    'unicodebbl|U!',
    'unicodebib|u!',
    'use-prd|p!',
    'bibdata|d=s',
    'allentries|a!',
    # 'convert|c=s',
    # 'type|t=s',
    'debug!',
    'help|h|?',
    'version|v'
);
use Regexp::Common qw /balanced/;
use Data::Dumper;    # for debug only
use Text::BibTeX;

use IO::File;
# This is of course temporary...
use lib '/home/francois/dev/biblatex-biber/trunk/lib'; 
use LaTeX::Decode;    #new package
use Encode;

use open IO => ':encoding(utf8)';
binmode( STDOUT, ':utf8' );
our $VERSION = "0.3";
die usage() if exists $opts->{'help'};

die version() if exists $opts->{'version'};

#TODO read config file (e.g. biber.cfg to change default options)

### Command-line options
my $fastsorting =
  exists $opts->{'fastsort'}
  ? $opts->{'fastsort'}
  : 0;
my $mincrossrefs =
  exists $opts->{'mincrossrefs'}
  ? $opts->{'mincrossrefs'}
  : 2;
my $unicodebbl =
  exists $opts->{'unicodebbl'}
  ? $opts->{'unicodebbl'}
  : 0;
my $unicodebib =
  exists $opts->{'unicodebib'}
  ? $opts->{'unicodebib'}
  : 0;
my $bibdata =
  exists $opts->{'bibdata'}
  ? $opts->{'bibdata'}
  : undef ;
my $allentries = 
  exists $opts->{'allentries'}
  ? $opts->{'allentries'}
  : 0;
my $useprd =
  exists $opts->{'use-prd'}
  ? $opts->{'use-prd'}
  : 0;
my $biberdebug =
  exists $opts->{'debug'}
  ? $opts->{'debug'}
  : 0;

### Biblatex default options
my %globaloptions = (
    debug =>     $biberdebug, #TODO : Biber's debug info will be necessarily different 
                             #       than that given by bibtex!
    labelalpha  => 0,
    useauthor   => 1,
    useeditor   => 1,
    usetranslator => 1,
    labelyear   => 0,
    labelnumber => 0,     #TODO ?
    singletitle => 0,
    uniquename  => 0,
    useprefix   => 0,
    terseinits  => 0,
    sorting     => 1,
    sortlos     => 1,
    maxnames    => 3,
    minnames    => 1,
    maxline     => 79,    #TODO ?
    alphaothers => "+"
);

require Unicode::Collate unless $fastsorting;

my $Collator = Unicode::Collate->new( level => 2 ) unless $fastsorting;

### biblatex fields

my @namefields =
  qw/author editor commentator translator redactor bookauthor afterword
  introduction holder sortname namea nameb namec/;
my @listfields =
  qw/publisher location address institution school language origlocation
  origpublisher lista listb listc listd liste listf/;

my @entriestosplit = ( @namefields, @listfields );

# literal and integer fields
my @literalfields =
  qw/abstract addendum annotation booksubtitle booktitle booktitleaddon chapter
  day edition eid howpublished indextitle isan isbn ismn isrn issn issue
  issuesubtitle issuetitle iswc journalsubtitle journaltitle journal label
  mainsubtitle maintitle maintitleaddon month nameaddon note number
  origtitle pagetotal part reprinttitle series shorthand shorthandintro
  shortjournal shortseries shorttitle subtitle title titleaddon eprinttype
  urlday urlmonth urlyear venue version volume volumes usera userb userc userd
  usere userf hyphenation crossref entrysubtype execute gender indexsorttitle
  sortkey sorttitle sortyear xref/;

# ignored by default: library remarks (more?)
# TODO add option to insert them if needed

my @rangefields    = qw/origyear pages year/;
my @verbatimfields = qw/doi eprint file pdf url verba verbb verbc/;
my @keyfields =
  qw/authortype bookpagination editortype origlanguage pagination type nameatype
  namebtype namectype/;
# TODO add keys for selecting script, language, translation, transliteration.

# TODO validate the keys in the @keyfields ?

push @literalfields, @keyfields;

#=====================================================
# Parse::RecDescent grammar for standard bibtex files
#=====================================================
#TODO package Biber::BibTeX::PRD ?
my $grammar = q{
     BibFile : <skip: qr{\s* (\%+[^\n]*\s*)*}x> Component(s) 
     #Comment(s) {1;} # { $return = { 'comments' => \@{$item[1]} } }
    Component : Preamble { 
                    $return = { 'preamble' => $item[1] } 
                       } 
           | String(s) { 
                     my @str = @{$item[1]};
                     $return = { 'strings' => \@str } ;
                     # we perform the substitutions now
                     foreach (@str) {
                     my ($a, $b) = split(/\s*=\s*/, $_, 2);
                     $b =~ s/^\s*"|"\s*$//g;
                     $text =~ s/$a\s*#?\s*(\{?)/$1$b/g
                     }
                 } 
           | BibEntry(s) { 
                    my @entries = @{$item[1]}; 
                    $return = { 'entries' => \@entries } 
               } 
           #     Comment : /\%+/ /[^\n]*\n+/  
     Preamble : '@PREAMBLE' PreambleString
     PreambleString : { 
                    my $value = extract_bracketed($text, '{}') ;
                    $value =~ s/^{(.*)}$/$1/s if $value;
                    $value =~ s/"\s*\n+\s*#/\n/mg;
                    #     $value =~ s/\n\s*/\n/g;
                    #   $value =~ s/^\s*{\s*(.+)\s*}\s*$/$1/s;
                    $value =~ s/^\s*"\s*//mg;
                    $value =~ s/\s*"\s*$//mg;
                    ($return) = $value if $value;
               }
     String : '@STRING' StringArg 
     StringArg : { 
                    my $value = extract_bracketed($text, '{}') ;
                    $value =~ s/\s*\n\s*/ /g;
                    ($return) = $value =~ /^{(.*)}$/s if $value;
               }
     BibEntry : '@' Typename '{' Key ',' Field(s) '}' /\n*/ { 
                   my %data = map { %$_ } @{$item[6]} ;
                    $return = { $item[4] => {entrytype => lc($item[2]), %data } } 
               }
     Typename : /[A-Za-z]+/ 
     Key : /[^,\s\n]+/
     Field : Fieldname /\s*=\s*/ Fielddata /,?/ {
                    $return = { $item[1] => $item[3] } 
               }
     Fieldname : /[A-Za-z]+/
     Fielddata : { 
                    my $value = extract_bracketed($text, '{}') ;
                    $value =~ s/\s*\n\s*/ /g;
                    ($return) = $value =~ /^{(.*)}$/s if $value;
             } 
             | { my $value = extract_delimited($text, '"') ;#"'
                    $value =~ s/\s*\n\s*/ /g;
                    ($return) = $value =~ /^"(.*)"$/s if $value;
               } 
               | /[^,]+/ { 
                    $return = $item[1] 
               } # {} or "" are not compulsory if on single line 
};

#=====================================================
# Parse AUX file
#=====================================================

my @auxcitekeys = () ;
my $citeallkeys = 0  ;
my %seenkeys    = () ;
my $bblfile ;
my @bibdatafiles = ();
push(@bibdatafiles, $bibdata) if $bibdata;

if ($allentries) {
        if ($bibdata) {
            $citeallkeys = 1;
            $bblfile = $bibdata;
            $bblfile =~ s/\..+$//;
            $bblfile .= ".bbl";
        }
        else {
            parse_auxfile();
            $citeallkeys = 1;
         }
}
else {
     parse_auxfile()
}

sub parse_auxfile {
    my $auxfile = $ARGV[0] || croak usage();
    $auxfile .= '.aux' unless $auxfile =~ m/\.aux$/;
    croak "Cannot find file '$auxfile'!\n" unless -f $auxfile;
    my $aux = new IO::File "<$auxfile" || croak "Failed to open $auxfile : $!";
    my $basefile = $auxfile;
    $basefile =~ s/\.aux$//;
    $bblfile = "$basefile.bbl";

    my $ctrl_file;

    local $/ = "\n";
    while (<$aux>) {
        if ( $_ =~ /^\\bibdata/ ) {
            # There can be more than one bibdata file!!! 
            # We should be able to parse many bib and/or xml files
            # Datafile given as option -d should be parsed first, then the other ones
            (my $bibdatastring) = m/^\\bibdata{([^}]+)}/;
            my @tmp = split/,/, $bibdatastring; 
            $ctrl_file = shift @tmp;
            push(@bibdatafiles, @tmp), 
        }
        if ( $_ =~ /^\\citation/ ) { 
            m/^\\citation{([^}]+)}/;  
            unless ( $seenkeys{$1} or $1 eq "biblatex-control" or $1 eq '*' ) {
                push @auxcitekeys, decode_utf8($1);
                $seenkeys{$1}++
            } 
            if ( $1 eq '*' ) {
                $citeallkeys = 1 
            }
        }
    } 
    if ($ctrl_file) {
        parse_ctrlfile($ctrl_file) 
    }
#    else {
#         parse_ctrlfile("$basefile-blx") <<< IGNORE IT IF NOT MENTIONED IN aux FILE
#    };
    
    unless (@bibdatafiles) {
        croak "No database was provided! Exiting"
    }

    unless ($citeallkeys or @auxcitekeys) {
        croak "File '$auxfile' does not contain any citations!"
    }
}

print "Found ", $#auxcitekeys+1 , " citekeys in aux file\n";

@auxcitekeys = sort @auxcitekeys if $biberdebug;

print "The citekeys are:\n", "@auxcitekeys", "\n\n" if ( $biberdebug and !$allentries);

#=====================================================
# PARSE CONTROL FILE with simple regex matching...
#=====================================================
#this is needed to generate the control macros in the bbl
#  version            = 0.8
#  ctrl-debug       = 0,
#  ctrl-bibtex8     = 0,     ignore
#  ctrl-terseinits  = 0,     package option (boolean)
#  ctrl-useprefix   = 0,     package option (boolean)
#  ctrl-useauthor   = 1,     package option (boolean)
#  ctrl-useeditor   = 1,     package option (boolean)
#  ctrl-labelalpha  = 0,     package option (boolean)
#  ctrl-labelyear   = 0,     package option (boolean)
#  ctrl-singletitle = 0,     package option (boolean)
#  ctrl-uniquename  = 0,     package option (0=false, 1=true, 2=init)
#  ctrl-sorting     = 1,     package option (key)
#  ctrl-sortlos     = 1,     package option (boolean)
#  ctrl-maxnames    = 3,     counter
#  ctrl-minnames    = 1,     counter
#  ctrl-maxline     = 79,    package option (counter: min value=49)
#  ctrl-alphaothers = {+}    string

#TODO warn instead and skip the following,
#     since we have the default values already...

sub parse_ctrlfile {
    my $ctrl_file = shift;
    croak "Cannot find control file '$ctrl_file.bib'!\n" unless -f "$ctrl_file.bib";
    my $ctrl = new IO::File "<$ctrl_file.bib"
          || croak "Cannot open $ctrl_file.bib: $!";
    while (<$ctrl>) {
        next unless /^\s*ctrl-options/;
        (my $opts) = /{(.+)}/;
        (my $controlversion,
        $globaloptions{debug},
        $globaloptions{bibtex8},
        $globaloptions{terseinits},
        $globaloptions{useprefix},
        $globaloptions{useauthor},
        $globaloptions{useeditor},
        $globaloptions{labelalpha},
        $globaloptions{labelyear},
        $globaloptions{singletitle},
        $globaloptions{uniquename},
        $globaloptions{sorting},
        $globaloptions{sortlos},
        $globaloptions{maxnames},
        $globaloptions{minnames},
        $globaloptions{maxline},
        $globaloptions{alphaothers}) = split /:/, $opts; 
        carp "Warning: You are not using biblatex version 0.8!\n" 
            unless substr($controlversion,0,2) eq '0.8';
    }
}

#======================================
# contains all the information needed for the output
my %bibentries = ();
# gives the number of times a certain key is cross-referenced
my %crossrefkeys = ();
# gives the crossref key for each citekey with a crossref
my %entrieswithcrossref = ();
my $preamble   = "";



#TODO : group xml and bib files together, and parse them together?
foreach my $bib (@bibdatafiles) {
    if ($bib =~ /\.xml$/) {
        parse_biblatexml( $bib )
    }
    elsif ($bib =~ /\.bib$/) {
        parse_bibtex($bib)
    }
    else {
        parse_bibtex("$bib.bib")
    }
}

@auxcitekeys = grep { defined $bibentries{$_} } @auxcitekeys;

######
# TODO move the following subs to external packages ?
######
#=====================================================
# Parse BIB file
#=====================================================

sub parse_bibtex {
    my $filename = shift;
    # citekeys that are in this database
    my @localkeys;
    print "Processing bibtex file $filename\n";

    if ( !$unicodebib && $unicodebbl ) {
        require File::Slurp;    #
        my $ufilename = "$filename.utf8";
        my $ubib      = new IO::File ">$ufilename";
        my $buf       = File::Slurp::read_file($filename) || croak "Can't read $filename";

        #TODO decode $buf if encoding is not UTF-8 : cmd-line option --inputencoding
        print $ubib latex_decode($buf) || croak "Can't write to $ufilename : $!";
        $ubib->close;
        $filename    = $ufilename;
        $unicodebib = 1;
    }

    if ( !$useprd and eval { require Text::BibTeX; 1 } ) {

        my $bib = new Text::BibTeX::File $filename
          || croak "Cannot create Text::BibTeX::File object from $filename: $!";

        #TODO validate with Text::BibTeX::Structure ?

        while ( my $entry = new Text::BibTeX::Entry $bib) {
            
            next if ( $entry->metatype == BTE_MACRODEF ) ;    

            my $key = $entry->key;
            print "Processing $key\n" if $biberdebug;
            if ( $bibentries{ $key } ) {
                print "We already have key $key! Ignoring in $filename...\n";
                next;
            }
            push @localkeys, $key;
            unless ($entry->parse_ok) {
                carp "Entry $key does not parse correctly: skipping" ;
                next ;
            }
            if ( $entry->type eq "preamble" ) {
                $preamble .= $entry->value;
            }
            elsif ( $entry->type ne "string" ) {
                foreach my $f ( $entry->fieldlist ) {
                    $bibentries{ $key }->{$f} =
                      decode_utf8( $entry->get($f) );
                }
                $bibentries{ $key }->{entrytype} = $entry->type;
                $bibentries{ $key }->{datatype} = 'bibtex';
            }
        }
    }
    else {
        require Parse::RecDescent;
        undef $/;

       #my $bib = new IO::File "<$filename" || croak "Failed to open $filename: $!";
       #TODO specify another encoding if not UTF-8 : cmd-line option --inputencoding
        open my $bib, "<:encoding(utf8)",
          $filename || croak "Failed to open $filename: $!";

        #$bib =~ s/\%+.*$//mg; # this gets rid of all comments

        my $btparser = Parse::RecDescent->new($grammar) || croak "Bad grammar: $!";
        my $bf       = $btparser->BibFile(<$bib>)       || croak "bad bib: $!";
        close $bib;

        my @tmp = @$bf;

        for my $n ( 0 .. $#tmp ) {
            my @tmpk   = keys %{ $tmp[$n] };
            my $tmpkey = $tmpk[0];
            if ( $tmpkey eq 'preamble' ) {
                $preamble = $tmp[$n]->{preamble};
            }
            elsif ( $tmpkey eq 'entries' ) {
                my @entries = @{ $tmp[$n]->{entries} };
                foreach my $i ( 0 .. $#entries ) {
                    my @tmpa   = keys %{ $entries[$i] };
                    my $tmpkey = $tmpa[0];
                    if ( $bibentries{ $tmpkey } ) {
                        carp "We already have key $tmpkey! Ignoring in $filename...";
                        next;
                    }
                    push @localkeys, $tmpkey;
                    $bibentries{$tmpkey} = $entries[$i]->{$tmpkey};
                    $bibentries{$tmpkey}->{datatype} = 'bibtex';
                }
            }
        }
    }

    foreach my $key ( @localkeys ) {
        foreach my $ets (@entriestosplit) {
            if ( exists $bibentries{$key}->{$ets} ) {
                my $tmp = $bibentries{$key}->{$ets};

                # "and" within { } must be preserved: see biblatex manual §2.3.3
                #      (this can probably be optimized)
                foreach my $x ( $tmp =~ m/($RE{balanced}{-parens => '{}'})/g ) {
                    ( my $xr = $x ) =~ s/\s+and\s+/_\x{ff08}_/g;
                    $tmp =~ s/\Q$x/$xr/g;
                }
                my @y = split /\s+and\s+/, $tmp;
                my @z;
                foreach (@y) {
                    s/_\x{ff08}_/ and /g;
                    push @z, $_;
                }
                $bibentries{$key}->{$ets} = [@z];
            }
        }
    }

    # Handling of crossrefs
    foreach my $citekey (@localkeys) {
        if ($bibentries{$citekey}->{crossref}) {
            my $crefkey = $bibentries{$citekey}->{crossref};
            $crossrefkeys{$crefkey}++;
            $entrieswithcrossref{$citekey} = $crefkey;
        }
    }

    process_crossrefs();    

#    return %bibentries
}


#FIXME unlink $ufilename if -f $ufilename ?

#=====================================================
# Parse XML file based on the biblatexml schema
#=====================================================

#TODO package Biber::BibLaTeXML ?
sub parse_biblatexml {
    my $xmlfile = shift;
    require XML::LibXML;
    my $parser = XML::LibXML->new();
    my $db = $parser->parse_file($xmlfile) 
        or croak "Can't parse file $xmlfile";

    # TODO : add option "validate xml" 
    # if ($validatexml) {
    #         my $rngschema = XML::LibXML::RelaxNG->new( location => "biblatexml.rng");
    #         my $validation = eval { $rngschema->validate($db) ; } ; 
    #         unless ($validation) {
    #             carp "The file $xmlfile does not validate against the biblatexml RelaxNG schema!\n$@"
    #         };
    # };
    
    # keep track of citekeys that were not found in this database
    my %citekeysnotfound = ();
    
    if ($citeallkeys) {
        @auxcitekeys = ();
        my $res = $db->findnodes('/*/bib:entry');
        foreach my $r ($res->get_nodelist) {
            push @auxcitekeys, $r->findnodes('@id')->string_value
        };
    };
    print "Processing $xmlfile ...\n";

    # Contrary to the bibtex approach, we are not extracting all data to
    # the bibentries hash, but only the ones corresponding to @auxcitekeys
    foreach my $citekey (@auxcitekeys) {
        next if $bibentries{$citekey}; # skip if this is already found in another database
        print "Looking for $citekey\n" if $biberdebug;
        my $xpath = '/*/bib:entry[@id="' . $citekey . '"]';
        my $results = $db->findnodes($xpath);
        unless ( $results ) {
            # print "Can't find entry with citekey $citekey... skipping\n";
            # we remove $citekey from @auxcitekeys
            $citekeysnotfound{$citekey} = 1;
            #@auxcitekeys = grep { $_ ne $citekey } @auxcitekeys;
            next
        };
        if ( $results->size() > 1 ) { 
            carp "The database contains more than one bib:entry with id=\"$citekey\" !" 
        };
        my $bibrecord = $results->get_node(1); 

        # if there is a crossref, we increment its citekey in %crossrefkeys
        if ( $bibrecord->findnodes('bib:crossref') ) {
            my $crefkey = $bibrecord->findnodes('bib:crossref')->string_value ;
            $crossrefkeys{$crefkey}++;
            $entrieswithcrossref{$citekey} = $crefkey;
        };
    };

    foreach my $k ( keys %crossrefkeys ) {
        push @auxcitekeys, $k unless $citeallkeys ;
    };
    #--------------------------------------------------

    foreach my $citekey (@auxcitekeys) {
        next if $citekeysnotfound{$citekey};
        next if $bibentries{$citekey}; # skip if this is already found in another database
        print "Processing key $citekey\n" if $biberdebug;
        my $xpath = '/*/bib:entry[@id="' . $citekey . '"]';
        my $results = $db->findnodes($xpath);
        my $bibrecord = $results->get_node(1); 

        $bibentries{ $citekey }->{entrytype} = $bibrecord->findnodes('@entrytype')->string_value;
        $bibentries{ $citekey }->{datatype} = 'xml';

        #TODO get the options field first 
        #options/text or option: key+value
        if ($bibrecord->findnodes("bib:options")) {
            if ($bibrecord->findnodes("bib:options/bib:option")) {
                my @opts; 
                foreach my $o ($bibrecord->findnodes("bib:options/bib:option")->get_nodelist) {
                    my $k = $o->findnodes("bib:key")->string_value; 
                    my $v = $o->findnodes("bib:value")->string_value;
                    push @opts, "$k=$v";
                };
                $bibentries{$citekey}->{options} = join(",", @opts);
            }
            else {
                $bibentries{$citekey}->{options} = $bibrecord->findnodes("bib:options")->string_value;
            }
        };
        
        # then we extract in turn the data from each type of fields

        foreach my $f (@literalfields, @verbatimfields) {
            $bibentries{$citekey}->{$f} = $bibrecord->findnodes("bib:$f")->string_value 
                if $bibrecord->findnodes("bib:$f");
        };

        foreach my $lf (@listfields) {
            my @z;
            if ($bibrecord->findnodes("bib:$lf")) {
                if ($bibrecord->findnodes("bib:$lf/bib:item")) {
                    foreach my $item ($bibrecord->findnodes("bib:$lf/bib:item")->get_nodelist) {
                        push @z, $item->string_value;
                    }
                }
                else {
                     push @z, $bibrecord->findnodes("bib:$lf")->string_value
                };
                if ($bibrecord->findnodes("bib:$lf\[\@andothers='true'\]")) {
                    push @z, "others"
                };
                $bibentries{$citekey}->{$lf} = [ @z ]
            }
        };

        foreach my $rf (@rangefields) {
            if ($bibrecord->findnodes("bib:$rf")) {
                if ($bibrecord->findnodes("bib:$rf/bib:start")) {
                     my $fieldstart = $bibrecord->findnodes("bib:$rf/bib:start")->string_value;
                     my $fieldend   = $bibrecord->findnodes("bib:$rf/bib:end")->string_value;
                    $bibentries{$citekey}->{$rf} = "$fieldstart--$fieldend";
                }
                elsif ($bibrecord->findnodes("bib:$rf/bib:list")) {
                    $bibentries{$citekey}->{$rf} = 
                        $bibrecord->findnodes("bib:$rf/bib:list")->string_value
                }
                else {
                    $bibentries{$citekey}->{$rf} = 
                        $bibrecord->findnodes("bib:$rf")->string_value
                }
            };
        };

        #the name fields are somewhat more complex
        my $usepre = getoption($citekey, 'useprefix');
        foreach my $nf (@namefields) {
            if ($bibrecord->findnodes("bib:$nf")) {
                my @z;
                if ($bibrecord->findnodes("bib:$nf/bib:person")) {
                    foreach my $person ($bibrecord->findnodes("bib:$nf/bib:person")->get_nodelist) {
                        my $last; 
                        my $first; 
                        my $prefix; 
                        my $suffix;
                        my $namestr = "";
                        my $nameinitstr = undef;
                        if ($person->findnodes('bib:last')) {
                            $last = $person->findnodes('bib:last')->string_value ;
                            $first = $person->findnodes('bib:first')->string_value ; 
                            $prefix = $person->findnodes('bib:prefix')->string_value 
                                if $person->findnodes('bib:prefix');
                            $suffix = $person->findnodes('bib:suffix')->string_value
                                if $person->findnodes('bib:suffix');
                            $namestr .= $prefix if $prefix;
                            $namestr .= $last;
                            $namestr .= ", " . $first if $first;
                            if ( $globaloptions{uniquename} == 2 ) {
                                $nameinitstr = "";
                                $nameinitstr .= substr( $prefix, 0, 1 ) . " "
                                  if ( $usepre and $prefix );
                                $nameinitstr .= $last;
                                $nameinitstr .= ", " . terseinitials($first) if $first;
                            } ;

                            push @z, 
                                { lastname => $last, firstname => $first, 
                                  prefix => $prefix, suffix => $suffix,
                                  namestring => $namestr, 
                                  nameinitstring => $nameinitstr }
                          }
                          # Schema allows <person>text<person>
                          else {
                              push @z, parsename( $person->string_value, 
                                                  { useprefix => $usepre } )
                          }
                    };
                } 
                # only one name as string, without <person>
                else {
                    push @z, parsename( $bibrecord->findnodes("bib:$nf")->string_value,
                                   { useprefix => $usepre } )
                };

                if ($bibrecord->findnodes("bib:$nf\[\@andothers='true'\]")) {
                    push @z, { lastname => "others", namestring => "others" }
                };
                
                $bibentries{$citekey}->{$nf} = [ @z ]
            }
        };

        # now we extract the attributes
        my %xmlattributes = ( 
            'bib:pages/@pagination' => 'pagination',
            'bib:pages/@bookpagination' => 'bookpagination',
            'bib:author/@type' => 'authortype',
            'bib:editor/@type' => 'editortype',
            'bib:author/@gender' => 'gender',
            # 'bib:editor/@gender' => 'gender', (ignored for now)
            '@howpublished' => 'howpublished'
            ); 
        foreach my $attr (keys %xmlattributes) {
            if ($bibrecord->findnodes($attr)) {
                $bibentries{ $citekey }->{ $xmlattributes{$attr} } 
                    = $bibrecord->findnodes($attr)->string_value ;
            }
        }
    };
     
    process_crossrefs();    

#    return %bibentries
}

#=====================================================
# INITIAL PREPROCESSING
#=====================================================

my %seenname       = ();
my %seenuniquename = ();
my %seenauthoryear = ();
my %seenlabelyear = ();

my @listofshorthands;
my %localoptions = ();

# split list entries

# if aux file contains \citation{*} then we create the complete bibliography
if ($citeallkeys) {
    @auxcitekeys = keys %bibentries ;
}

#=====================================================
# SUBS for PREPROCESSING the ENTRIES
#=====================================================
sub process_crossrefs {
    foreach my $citekeyx (keys %entrieswithcrossref) {
        my $xref = $entrieswithcrossref{$citekeyx}; 
        my $type = $bibentries{$citekeyx}->{entrytype};
        if ($type eq 'review') {
                #TODO
        }
        if ($type =~ /^in(proceedings|collection|book)$/) {
            # inherit all that is undefined, except title etc
            foreach my $field (keys %{$bibentries{$xref}}) {
                next if $field =~ /title/;
                if (! $bibentries{$citekeyx}->{$field}) {
                    $bibentries{$citekeyx}->{$field} = $bibentries{$xref}->{$field};
                }
            }
            # inherit title etc as booktitle etc
            $bibentries{$citekeyx}->{booktitle} = $bibentries{$xref}->{title}; 
            if ($bibentries{$xref}->{titleaddon}) {
                $bibentries{$citekeyx}->{booktitleaddon} = $bibentries{$xref}->{titleaddon}
            }
            if ($bibentries{$xref}->{subtitle}) {
                $bibentries{$citekeyx}->{booksubtitle} = $bibentries{$xref}->{subtitle}
            }
        }
        else { # inherits all
            foreach my $field (keys %{$bibentries{$xref}}) {
                if (! $bibentries{$citekeyx}->{$field}) {
                    $bibentries{$citekeyx}->{$field} = $bibentries{$xref}->{$field};
                }
            }
       }
       if ($type eq 'inbook') {
            $bibentries{$citekeyx}->{bookauthor} = $bibentries{$xref}->{author} 
        }
        # MORE?
        #$bibentries{$citekeyx}->{} = $bibentries{$xref}->{} 
    }

    # we make sure that keys that are cross-referenced 
    # less than $mincrossrefs are not included the bibliography
    foreach my $k ( keys %crossrefkeys ) {
        if ( $crossrefkeys{$k} >= $mincrossrefs ) {
            delete $crossrefkeys{$k};
        }
    }    
}


sub parsename {
    my ($namestr, $argref) = @_;
    my $usepre = $argref->{useprefix} || $globaloptions{useprefix} ;
    my $lastname;
    my $firstname = undef;
    my $prefix   = undef;
    my $suffix   = undef;
    my $nameinitstr = undef;
    
    #  Arabic last names could begin with diacritics like ʿ or ‘ (e.g. ʿAlī)
    my $diacritics = qr/[\x{2bf}\x{2018}]/; # more? FIXME
    #  Arabic names may be prefixed with an article (e.g. al-Hasan, as-Saleh)
    my $articleprefix = qr/\p{Ll}{2}-/; # etc

    if ( $namestr =~ /,.+,/ ) {    # pre? Lastname, suffix, Firstname
        ( $prefix, $lastname, $suffix, $firstname ) = $namestr =~
            m/^(\p{Ll}(?:\p{Ll}|\s)+)?\s*(\p{Lu}[^,]+|{[^\\][^,]+}),\s+([^,]+),\s+([^,]+)$/x;

        #$lastname =~ s/^{(.+)}$/$1/g ;
        #$firstname =~ s/^{(.+)}$/$1/g ;
        $prefix =~ s/\s+$// if $prefix;
    }
    elsif ( $namestr =~ /,/ ) {    # <pre> Lastname, Firstname
        ( $prefix, $lastname, $firstname ) = $namestr =~
            m/^(\p{Ll}(?:\p{Ll}|\s)+\s+)?($articleprefix?$diacritics?\p{L}[^,]+|{[^,]+}),\s+([^,]+|{.+})$/x;

        #$lastname =~ s/^{(.+)}$/$1/g ;
        #$firstname =~ s/^{(.+)}$/$1/g ;
        $prefix =~ s/\s+$// if $prefix;
    }
    elsif ( $namestr =~ /\s/ and $namestr !~ /^{.+}$/ ) {  # Firstname pre? Lastname
        ( $firstname, $prefix, $lastname ) =
          $namestr =~ /^({.+}|(?:\p{Lu}\p{Ll}+\s*)+)\s+((?:\p{Ll}|\s)+)?(.+)$/x;

        #$lastname =~ s/^{(.+)}$/$1/;
        $firstname =~ s/\s+$// if $firstname;

        #$firstname =~ s/^{(.+)}$/$1/ if $firstname;
        $prefix =~ s/\s+$// if $prefix;
        $namestr = "";
        $namestr = $prefix if $prefix;
        $namestr .= $lastname;
        $namestr .= ", " . $firstname if $firstname;
    }
    else {    # Name alone
        $lastname = $namestr;

        #$lastname =~ s/^{(.+)}$/$1/;
    }

    #TODO? $namestr =~ s/[\p{P}\p{S}\p{C}]+//g;
    ## remove punctuation, symbols, separator and control ???

    if ( $globaloptions{uniquename} == 2 ) {
        $nameinitstr = "";
        $nameinitstr .= substr( $prefix, 0, 1 ) . " " if ( $usepre and $prefix );
        $nameinitstr .= $lastname;
        $nameinitstr .= ", " . terseinitials($firstname) if $firstname;
    };

    return {
            namestring     => $namestr,
            nameinitstring => $nameinitstr,
            lastname       => $lastname,
            firstname      => $firstname,
            prefix         => $prefix,
            suffix         => $suffix
           }
}

sub terseinitials {
    my $str = shift;    #FIXME decode_latex first ?
    carp "String not defined" unless ($str) ;
    $str =~ s/^{(\p{L}).+}$/$1/g;    # Aaaaa{ de }Bbbb -> A
    $str =~ s/{\s+(\S+)\s+}/~$1~/g;  # {Aaaa Bbbbb Ccccc} -> A
    # get rid of Punctuation (except DashPunctuation), Symbol and Other characters
    $str =~ s/[\x{2bf}\x{2018}\p{Po}\p{Pc}\p{Ps}\p{Pe}\p{S}\p{C}]+//g; 
    $str =~ s/[\b~]a.-\p{L}//; # remove arabic prefix: al-Khwarizmi -> K as-Saleh -> S ʿAbd~al-Raḥmān -> A etc
    $str =~ s/\B\p{L}//g;
    $str =~ s/\s+//g;
    return $str;
}

sub getnameinitials {
    my ($citekey, @aut) = @_;
    my $initstr = "";
    if ( $#aut < getoption( $citekey, "maxnames" ) ) {    # 1 to 3 authors
        foreach my $a (@aut) {
            if ( $a->{prefix} and getoption( $citekey, "useprefix" ) ) {
                $initstr .= terseinitials( $a->{prefix} );
            }
            $initstr .= terseinitials( $a->{lastname} );

            #FIXME suffix ?
            if ( $a->{firstname} ) {
                $initstr .= terseinitials( $a->{firstname} );
            }
        }
    }
    else
    { # more than 3 authors: only take initials of first getoption($citekey,"minnames")
            #TODO
        foreach my $i ( 0 .. getoption( $citekey, "minnames" ) - 1 ) {
            if ( $aut[$i]->{prefix} and getoption( $citekey, "useprefix" ) ) {
                $initstr .= terseinitials( $aut[$i]->{prefix} );
            }
            my $tmp = $aut[$i]->{lastname};

            #FIXME suffix ?
            $initstr .= terseinitials($tmp);
            if ( $aut[$i]->{firstname} ) {
                $tmp = $aut[$i]->{firstname};
                $initstr .= terseinitials($tmp);
            }
            $initstr .= "+";
        }
    }
    return $initstr;
}

sub getallnameinitials {
    my ($citekey, @aut) = @_;
    my $initstr = "";
    foreach my $a (@aut) {
        if ( $a->{prefix} and getoption( $citekey, "useprefix" ) ) {
            $initstr .= terseinitials( $a->{prefix} );
        }
        $initstr .= terseinitials( $a->{lastname} );

        #FIXME suffix ?
        if ( $a->{firstname} ) {
            $initstr .= terseinitials( $a->{firstname} );
        }
    }
    return $initstr;
}

#sub gettitleinitials {
#     my $title = shift;
#     $title =~ s/\b(\p{L})\S*\b\s*/$1/g;
#     $title =~ s/\P{L}//g;
#     return $title
#}

sub makenameid {
    my @names = @_;
    my @namestrings;
    foreach my $n (@names) {
        push @namestrings, $n->{namestring};
    }
    my $tmp = join " ", @namestrings;
    return cleanstring($tmp);
}

sub makenameinitid {
    my @names = @_;
    my @namestrings;
    foreach my $n (@names) {
        push @namestrings, $n->{nameinitstring};
    }
    my $tmp = join " ", @namestrings;
    return cleanstring($tmp);
}

sub cleanstring {
    my $str = shift;
    croak "String not defined" unless ($str) ;
    $str =~ s/\\[A-Za-z]+//g;  ### (hyphen|q?quad|e[nm]space|-)//g; #FIXME more?
    $str =~ s/[\p{P}\p{S}\p{C}]+//g
      ;    # remove punctuation, symbols, separator and control
    $str =~ s/\s+/_/g;
    return $str;
}

sub normalize_string {
    my $str = shift;
    my $datatype = shift;
    croak "String not defined" unless ($str) ;
    $str = latex_decode($str) unless ( $unicodebib or $fastsorting or $datatype eq 'xml' );
    $str =~ s/\\[A-Za-z]+//g;  ### (hyphen|q?quad|e[nm]space|-)//g; #FIXME more?
    $str =~ s/[\p{P}\p{S}\p{C}]+//g
      ;    # remove punctuation, symbols, separator and control
    return $str;
}

sub getoption {
    my $citekey = shift;
    my $opt = shift;
    if ( defined $localoptions{$citekey} and defined $localoptions{$citekey}->{$opt} ) {
        return $localoptions{$citekey}->{$opt};
    }
    else {
        return $globaloptions{$opt};
    }
}

#=====================================================
# SUBS for SORT STRINGS
#=====================================================

sub getinitstring {
    my $citekey = shift;
    my $str;
    if ( $bibentries{$citekey}->{presort} ) {
        $str = $bibentries{$citekey}->{presort};
    }
    else {
        $str = "mm";
    }
    if ( $bibentries{$citekey}->{labelalpha} ) {
        $str .= $bibentries{$citekey}->{labelalpha};
    }
    return $str;
}

sub getnamestring {
    my $citekey = shift;

    # see biblatex manual §3.4 "if both are disabled, the sortname field is ignored as well"
    if (
        $bibentries{$citekey}->{sortname}
        and (     getoption( $citekey, "useauthor" )
               or getoption( $citekey, "useeditor" )  
            )
      )
    {
        return $bibentries{$citekey}->{sortname};
    }
    elsif ( getoption( $citekey, "useauthor" ) and $bibentries{$citekey}->{author} ) {
        return _namestring($citekey,'author')
    }
    elsif ( getoption( $citekey, "useeditor" ) and $bibentries{$citekey}->{editor} ) {
        return _namestring($citekey, 'editor')
    }
    elsif ( getoption( $citekey, "usetranslator" ) and $bibentries{$citekey}->{translator} ) {
        return _namestring($citekey, 'translator')
    }
    else {
        return gettitlestring($citekey);
    }
}


sub _namestring {
    my ( $citekey, $field ) = @_;
    my $dt = $bibentries{$citekey}->{datatype};
    my $str = "";
    foreach ( @{ $bibentries{$citekey}->{$field} } ) {
        $str .= $_->{prefix} . " "
          if ( $_->{prefix} and getoption( $citekey, "useprefix" ) );
        $str .= $_->{lastname} . " ";
        $str .= $_->{firstname} . " " if $_->{firstname};
        $str .= $_->{suffix} if $_->{suffix};
        $str .= " ";
    };
    $str =~ s/\s+$//;
    return normalize_string($str, $dt)
}

sub getyearstring {
    my $citekey = shift;
    if ( $bibentries{$citekey}->{sortyear} ) {
        return substr( $bibentries{$citekey}->{sortyear}, 0, 4 );
    }
    elsif ( $bibentries{$citekey}->{year} ) {
        return substr( $bibentries{$citekey}->{year}, 0, 4 )

          #     } elsif ($bibentries{$citekey}->{date}) {
          #          return substr($bibentries{$citekey}->{date}, 0, 4)
    }
    else {
        return "9999";
    }
}

sub getdecyearstring {
    my $citekey = shift;
    if ( $bibentries{$citekey}->{sortyear} ) {
        return 9999 - substr( $bibentries{$citekey}->{sortyear}, 0, 4 );
    }
    elsif ( $bibentries{$citekey}->{year} ) {
        return 9999 - substr( $bibentries{$citekey}->{year}, 0, 4 )

          #     } elsif ($bibentries{$citekey}->{date}) {
          #          return 9999 - substr($bibentries{$citekey}->{date}, 0, 4)
    }
    else {
        return "9999";
    }
}

sub gettitlestring {
    my $citekey = shift;
    my $dt = $bibentries{$citekey}->{datatype};
    if ( $bibentries{$citekey}->{sorttitle} ) {
        return normalize_string( $bibentries{$citekey}->{sorttitle}, $dt );
    }
    elsif ( $bibentries{$citekey}->{title} ) {
        return normalize_string( $bibentries{$citekey}->{title}, $dt );
    }
    elsif ($bibentries{$citekey}->{issuetitle}) {
        return normalize_string( $bibentries{$citekey}->{issuetitle}, $dt );
    }
    elsif ($bibentries{$citekey}->{journal}) {
        return normalize_string( $bibentries{$citekey}->{journal}, $dt );
    }
    else {
        croak "No title available for gettitlestring()"
    }
}

sub getvolumestring {
    my $citekey = shift;
    if ( $bibentries{$citekey}->{volume} ) {
        my $vol = $bibentries{$citekey}->{volume};

        #          if ($vol =~ /^[0-9]+/) {
        #               $vol =~ s/^([0-9]+).*$/$1/;
        #               return sprintf("%04d", $vol)
        #          } else {
        return sprintf( "%04s", $vol )

          #          }
    }
    else {
        return "0000";
    }
}

#open DUMP, ">BIBENTRIES.TMP";
#print DUMP Dumper \%bibentries;
#close DUMP;


###############################################
# internal post-processing to prepare output

#------------------------------------------------
# parse names, generate namehash and strings for "uniquename", "labelyear",
# "labelalpha", "sortstrings", etc

foreach my $citekey (@auxcitekeys) {
    unless ( $bibentries{$citekey} ) {
        print "Could not find key $citekey in the database(s)! Skipping...\n" ;
        next;
    };
    #print "postprocessing $citekey\n";
    my $dt = $bibentries{$citekey}->{datatype};
    
    # TODO move this to parse_bibtex() function ?
    unless ($dt eq 'xml') {
        # parse name entries into hashes containing the different parts of each name
        foreach my $field (@namefields) {
            next unless $bibentries{$citekey}->{$field};
            my @names = @{ $bibentries{$citekey}->{$field} };
            my @nameAoH;    # array of hashes
            foreach my $name (@names) {
                push @nameAoH, parsename( $name, { useprefix => getoption($citekey, 'useprefix') } );
            }
            $bibentries{$citekey}->{$field} = [@nameAoH];
        }
    }

    # get day month year from date field if no year is supplied
    if ( $bibentries{$citekey}->{date} && !$bibentries{$citekey}->{year} ) {
        my $date = $bibentries{$citekey}->{date};
        $bibentries{$citekey}->{year}  = substr $date, 0, 4;
        $bibentries{$citekey}->{month} = substr $date, 5, 2 if length $date > 6;
        $bibentries{$citekey}->{day}   = substr $date, 8, 2 if length $date > 9;
    }
    
    ## set local options to override global options for individual entries
    if ( $bibentries{$citekey}->{options} ) {
        my @entryoptions = split /\s*,\s*/, $bibentries{$citekey}->{options};
        foreach (@entryoptions) {
            m/^([^=]+)=?(.+)?$/;
            if ( $2 and $2 eq "false" ) {
                $localoptions{$citekey}->{$1} = 0;
            }
            elsif ( $2 and $2 eq "true" ) {
                $localoptions{$citekey}->{$1} = 1;
            }
            elsif ($2) {
                $localoptions{$citekey}->{$1} = $2;
            }
            else {
                $localoptions{$citekey}->{$1} = 1;
            }
        }
    }

    # determine "namehash" field for biblatex
    my $namehash;
    my $fullhash;
    my $nameid;
    my $nameinitid;
    if ( $bibentries{$citekey}->{sortname}
         and (   getoption( $citekey, "useauthor" ) 
              or getoption( $citekey, "useeditor" ) 
             )
       )
    {
        my @aut = @{ $bibentries{$citekey}->{sortname} };
        $namehash   = getnameinitials( $citekey, @aut );
        $fullhash   = getallnameinitials( $citekey, @aut );
        $nameid     = makenameid(@aut);
        $nameinitid = makenameinitid(@aut)
          if ( $globaloptions{uniquename} == 2 );
    }
    elsif ( getoption( $citekey, "useauthor" ) 
            and $bibentries{$citekey}->{author} ) {
        my @aut = @{ $bibentries{$citekey}->{author} };
        $namehash   = getnameinitials( $citekey, @aut );
        $fullhash   = getallnameinitials( $citekey, @aut );
        $nameid     = makenameid(@aut);
        $nameinitid = makenameinitid(@aut)
          if ( $globaloptions{uniquename} == 2 );
    }
    elsif ( ($bibentries{$citekey}->{entrytype} =~ /^(collection|proceedings)/ 
                or getoption( $citekey, "useeditor" ) )
            and $bibentries{$citekey}->{editor} ) 
    {
        my @edt = @{ $bibentries{$citekey}->{editor} };
        $namehash   = getnameinitials( $citekey, @edt );
        $fullhash   = getallnameinitials( $citekey, @edt );
        $nameid     = makenameid(@edt);
        $nameinitid = makenameinitid(@edt)
          if ( $globaloptions{uniquename} == 2 );
    }
    elsif ( getoption( $citekey, "usetranslator" ) 
            and $bibentries{$citekey}->{translator} ) 
    {
        my @edt = @{ $bibentries{$citekey}->{translator} };
        $namehash   = getnameinitials( $citekey, @edt );
        $fullhash   = getallnameinitials( $citekey, @edt );
        $nameid     = makenameid(@edt);
        $nameinitid = makenameinitid(@edt)
          if ( $globaloptions{uniquename} == 2 );
    }
    else {    # initials of title
        if ( $bibentries{$citekey}->{sorttitle} ) {
            $namehash   = terseinitials( $bibentries{$citekey}->{sorttitle} );
            $fullhash   = $namehash;
            $nameid     = cleanstring( $bibentries{$citekey}->{sorttitle} );
            $nameinitid = $nameid if ( $globaloptions{uniquename} == 2 );
        }
        else {
#            print "Something wrong with $citekey ?  \n--------------\n";
#            my %tmp = %{$bibentries{$citekey}};
#            print Dumper \%tmp;
#            print "\n--------------\n";
            $namehash   = terseinitials( $bibentries{$citekey}->{title} );
            $fullhash   = $namehash;
            $nameid     = cleanstring( $bibentries{$citekey}->{title} );
            $nameinitid = $nameid if ( $globaloptions{uniquename} == 2 );
        }
    }

    $seenname{$nameid}++;
    $namehash .= $seenname{$nameid};
    $fullhash .= $seenname{$nameid};
    $bibentries{$citekey}->{namehash} = $namehash;
    $bibentries{$citekey}->{fullhash} = $fullhash;

    if ( $globaloptions{uniquename} == 2 ) {
        $seenuniquename{$nameinitid}++;
        $bibentries{$citekey}->{uniquename} = $nameinitid;
    }
    else {
        $seenuniquename{$nameid}++;
        $bibentries{$citekey}->{uniquename} = $nameid;
    }


    ### Generate the labelalpha --- TODO : check for labelname ??
    if ( $globaloptions{labelalpha} ) {
        my $label;

        if ($bibentries{$citekey}->{shorthand}) 
        {
            $label = $bibentries{$citekey}->{shorthand} 
        }
        else 
        {
            if ($bibentries{$citekey}->{label}) 
            {
                $label = $bibentries{$citekey}->{label}
            } 
            elsif ( $bibentries{$citekey}->{author} and getoption( $citekey, "useauthor" ) ) 
            { 
            # TODO option $useprefix needs to be taken into account!
            # TODO CHECK FOR  $useauthor and $useeditor also in $bibentry{$citekey}->{options}
                my @names     = @{ $bibentries{$citekey}->{author} };
                my @lastnames = map { normalize_string( $_->{lastname}, $dt ) } @names;
                my $noofauth  = scalar @names;
                if ( $noofauth > 3 ) {
                    $label =
                      substr( $lastnames[0], 0, 3 ) . $globaloptions{alphaothers};
                }
                elsif ( $noofauth == 1 ) {
                    $label = substr( $lastnames[0], 0, 3 );
                }
                else {
                    foreach my $n (@lastnames) {
                        $n =~ s/\P{Lu}//g;
                        $label .= $n;
                    }
                }
            }
            elsif ( $bibentries{$citekey}->{editor} and getoption( $citekey, "useeditor" ) )
            {
                my @names     = @{ $bibentries{$citekey}->{editor} };
                my @lastnames = map { normalize_string( $_->{lastname}, $dt ) } @names;
                my $noofauth  = scalar @names;
                if ( $noofauth > 3 ) {
                    $label =
                      substr( $lastnames[0], 0, 3 ) . $globaloptions{alphaothers};
                }
                elsif ( $noofauth == 1 ) {
                    $label = substr( $lastnames[0], 0, 3 );
                }
                else {
                    foreach my $n (@lastnames) {
                        $n =~ s/\P{Lu}//g;
                        $label .= $n;
                    }
                }
            }
            else 
            {
                $label = "Zzz"    # ??? FIXME
            };
            my $yr;
            if ( $bibentries{$citekey}->{year} ) {
                $yr = substr $bibentries{$citekey}->{year}, 2, 2;
            }
            else {
                $yr = "00";
            }

            $label .= $yr;
        };

        $bibentries{$citekey}->{labelalpha} = $label;
    }

    my $tmp = getnamestring($citekey) . " " . getyearstring($citekey);
    $seenauthoryear{$tmp}++;
    $bibentries{$citekey}->{authoryear} = $tmp;

    if ( $bibentries{$citekey}->{shorthand} ) {
        push @listofshorthands, $citekey;
    }
    ### MAKE SORT STRINGS ###
    if ( $globaloptions{sorting} == 1 ) {    # name title year
        $bibentries{$citekey}->{sortstring} =
          lc(   getinitstring($citekey) . " "
              . getnamestring($citekey) . " "
              . gettitlestring($citekey) . " "
              . getyearstring($citekey) . " "
              . getvolumestring($citekey) );
    }
    elsif ( $globaloptions{sorting} == 2 or $globaloptions{sorting} == 12 )
    {                                        # <alpha> name year title
        $bibentries{$citekey}->{sortstring} =
          lc(   getinitstring($citekey) . " "
              . getnamestring($citekey) . " "
              . getyearstring($citekey) . " "
              . gettitlestring($citekey) . " "
              . getvolumestring($citekey) );
    }
    elsif ( $globaloptions{sorting} == 3 or $globaloptions{sorting} == 13 )
    {                                        # <alpha> name year volume title
        $bibentries{$citekey}->{sortstring} =
          lc(   getinitstring($citekey) . " "
              . getnamestring($citekey) . " "
              . getyearstring($citekey) . " "
              . getvolumestring($citekey) . " "
              . gettitlestring($citekey) );
    }
    elsif ( $globaloptions{sorting} == 21 ) {    # year name title
        $bibentries{$citekey}->{sortstring} =
          lc(   getyearstring($citekey) . " "
              . getnamestring($citekey) . " "
              . gettitlestring($citekey) );
    }
    elsif ( $globaloptions{sorting} == 22 ) {    # year_decreasing name title
        $bibentries{$citekey}->{sortstring} =
          lc(   getdecyearstring($citekey) . " "
              . getnamestring($citekey) . " "
              . gettitlestring($citekey) );

    #} TODO elsif ($globaloptions{sorting} == 99) { #DEBUG ???
    }
    else {
        # do nothing!
        carp "Warning: the sorting code $globaloptions{sorting} is not defined, ignoring!\n";
    }
}

#===========================
# SORTING
#===========================

if ( $globaloptions{sorting} ) {
    if ($fastsorting) {
        @auxcitekeys = sort {
            $bibentries{$a}->{sortstring} cmp $bibentries{$b}->{sortstring}
        } @auxcitekeys;
    }
    else {
        @auxcitekeys = sort {
            $Collator->cmp( $bibentries{$a}->{sortstring},
                $bibentries{$b}->{sortstring} )
        } @auxcitekeys;
    }
}

#====================================
# output subs
#====================================

sub getpartinitials {
    my $part = shift;
    $part = terseinitials($part);
    unless ( $globaloptions{terseinits} ) {
        $part =~ s/(\p{L})/$1\.~/g ;
        $part =~ s/~-/-/g ; 
        $part =~ s/~$//;
    }
    return $part;
}

# TODO "D[onald] E. Knuth" -> prints as D. E. Knuth but is sorted with Donald E. Knuth
sub print_name {
    my $au  = shift;
    my %nh  = %{$au};
    my $ln  = $nh{lastname};
    my $lni = getpartinitials($ln);
    my $fn  = "";
    $fn = $nh{firstname} if $nh{firstname};
    my $fni = "";
    $fni = getpartinitials($fn) if $nh{firstname};
    my $pre = "";
    $pre = $nh{prefix} if $nh{prefix};
    my $prei = "";
    $prei = getpartinitials($pre) if $nh{prefix};
    my $suf = "";
    $suf = $nh{suffix} if $nh{suffix};
    my $sufi = "";
    $sufi = getpartinitials($suf) if $nh{suffix};
    return "    {{$ln}{$lni}{$fn}{$fni}{$pre}{$prei}{$suf}{$sufi}}%\n";
}

sub latexescape { 
    my $str = shift;
    my @latexspecials = ( '&', '\^', '_', '\$', '%' ); 
    foreach my $char (@latexspecials) {
        $str =~ s/[^\\]$char/\\$char/g;
    };
    return $str
}

sub print_for_biblatex {
    my $citekey = shift;
    my $be      = $bibentries{$citekey} || croak "Cannot find $citekey hash";
    my $kw      = "";
    if ( $bibentries{$citekey}->{keywords} ) {
        $kw = $bibentries{$citekey}->{keywords};
    }
    my $str = "\\entry{$citekey}{" . $be->{entrytype} . "}{$kw}\n";
    delete $be->{entrytype};
    foreach my $namefield (@namefields) {
        if ( defined $be->{$namefield} ) {
            my @nf    = @{ $be->{$namefield} };
            if ( $be->{$namefield}->[-1]->{namestring} eq 'others' ) {
                $str .= "  \\true{more$namefield}\n";
                pop @nf; # remove the last element in the array
            };
            my $total = $#nf + 1;
            $str .= "  \\name{$namefield}{$total}{%\n";
            foreach my $n (@nf) {
                $str .= print_name($n);
            }
            $str .= "  }\n";
        }
    }
    foreach my $listfield (@listfields) {
        if ( defined $be->{$listfield} ) {
            my @nf    = @{ $be->{$listfield} };
            if ( $be->{$listfield}->[-1] eq 'others' ) {
                $str .= "  \\true{more$listfield}\n";
                pop @nf; # remove the last element in the array
            };
            my $total = $#nf + 1;
            $str .= "  \\list{$listfield}{$total}{%\n";
            foreach my $n (@nf) {
                if ($be->{datatype} eq 'bibtex') {
                    $str .= "    {$n}%\n";
                }
                else {
                    $str .= "    {" . latexescape($n) ."}%\n";
                }
            }
            $str .= "  }\n";
        }
    }

    my $namehash = $be->{namehash};
    my $sortinit = substr $namehash, 0, 1;
    $str .= "  \\strng{namehash}{$namehash}\n";
    my $fullhash = $be->{fullhash};
    $str .= "  \\strng{fullhash}{$fullhash}\n";
    if ( $globaloptions{labelalpha} ) {
        my $label = $be->{labelalpha};
        $str .= "  \\field{labelalpha}{$label}\n";
    }
    $str .= "  \\field{sortinit}{$sortinit}\n";
    
    if ( $globaloptions{labelyear} ) {
        my $authoryear = $be->{authoryear};
        if ( $seenauthoryear{$authoryear} > 1) {
            $seenlabelyear{$authoryear}++;
            $str .= "  \\field{labelyear}{" 
              . $seenlabelyear{$authoryear} . "}\n";
        }
    }

    if ( $globaloptions{extraalpha} ) {
        my $authoryear = $be->{authoryear};
        if ( $seenauthoryear{$authoryear} > 1) {
            $seenlabelyear{$authoryear}++;
            $str .= "  \\field{extraalpha}{" 
              . $seenlabelyear{$authoryear} . "}\n";
        }
    }

    if ( $globaloptions{labelnumber} ) {
        if ($be->{shorthand}) {
            $str .= "  \\field{labelnumber}{"
              . $be->{shorthand} . "}\n";
        } 
        elsif ($be->{labelnumber}) {
            $str .= "  \\field{labelnumber}{"
              . $be->{labelnumber} . "}\n";
        } 
    }

    # FIXME : currently bibtex only outputs \count{uniquename}{0} !
    if ( $globaloptions{uniquename} > 0 ) {
        $str .= "  \\count{uniquename}{"
          . $seenuniquename{ $be->{uniquename} } . "}\n";
    }

    if (    $globaloptions{singletitle}
        and $seenuniquename{ $be->{uniquename} } < 2 )
    {
        $str .= "  \\true{singletitle}\n";
    }

    foreach my $lfield (@literalfields) {
        if ( defined $be->{$lfield} ) {
            next
              if $lfield eq "crossref"
                  and $seenkeys{ $be->{crossref} };  # belongs to @auxcitekeys ;
            my $lfieldprint = $lfield ;
            if ($lfield eq 'journal') {
                $lfieldprint = 'journaltitle' 
            };
            if ($be->{datatype} eq 'bibtex') {
                $str .= "  \\field{$lfieldprint}{" . $be->{$lfield} . "}\n";
            }
            else {
                $str .= "  \\field{$lfieldprint}{" . latexescape($be->{$lfield}) . "}\n";
            }
        }
    }
    foreach my $rfield (@rangefields) {
        if ( defined $be->{$rfield} ) {
            my $rf = $be->{$rfield};
            $rf =~ s/-+/\\bibrangedash /g;
            $str .= "  \\field{$rfield}{$rf}\n";
        }
    }
    foreach my $vfield (@verbatimfields) {
        if ( defined $be->{$vfield} ) {
            my $rf = $be->{$vfield};
            $str .= "  \\verb{$vfield}\n";
            $str .= "  \\verb $rf\n  \\endverb\n";
        }
    }
    if ( defined $be->{options} ) {
        $str .= "  \\options{" . $be->{options} . "}\n";
    }

    #TODO generate special fields : see manual §4.2.4
    $str .= "\\endentry\n\n";

    #     $str = encode_utf8($str) if $unicodebbl;
    return $str;
}

sub version {
    my $me = "biber";    #basename($0);

    qq[
$me Version: $VERSION
      \n]
}

sub usage {
    my $me = "biber";    #basename($0);

    qq[
Usage:  $me <file>.aux
     Creates <file>.bbl

Options:
  --help|-h             Show this help message.
  --version|-v          Display version number.
  --mincrossrefs|-m <n> Set treshold for crossrefs.
  --fastsort|-f         Do not use LaTeX_Decode and Unicode::Collate for sorting
  --use-prd|-p          Force parsing with Parse::RecDescent
  --bibdata|-d <file>    Use <file> as the bibliography database
  --allentries|-a        Output all entries in the database
  --unicodebib|-u       Assume bib file is UTF-8 and skip latex_decode
  --unicodebbl|-U       Encode the bbl output in UTF-8
    \n]
}

#=====================================================
# OUTPUT .BBL FILE FOR BIBLATEX
#=====================================================
#my $bbl = new IO::File ">$bblfile";

#open(BBL, ">:utf8", "$bblfile");

open( BBL, ">$bblfile" );

my $BBL = <<"EOF"
% \$ biblatex auxiliary file \$
% \$ biblatex version 0.8 \$
% Do not modify the above lines!
%
% This is an auxiliary file used by the 'biblatex' package.
% This file may safely be deleted. It will be recreated as
% required.
%
\\begingroup
\\makeatletter
\\\@ifundefined{ver\@biblatex.sty}
  {\\\@latex\@error
     {Missing `biblatex' package}
     {The bibliography requires the `biblatex' package.}
      \\aftergroup\\endinput}
  {}
\\endgroup

EOF
  ;

$BBL .= "\\preamble{%\n$preamble\n}\n" if $preamble;

foreach my $k (@auxcitekeys) {
    next if $crossrefkeys{$k};
    $BBL .= print_for_biblatex($k);
}
if ( $globaloptions{sortlos} and @listofshorthands ) {
    $BBL .= "\\lossort\n";
    foreach (@listofshorthands) {
        $BBL .= "  \\key{$_}\n";
    }
    $BBL .= "\\endlossort\n";
}
$BBL .= "\\endinput\n";
carp "The output does not appear to be valid UTF-8!" unless Encode::is_utf8($BBL);

#$BBL = decode('utf8', $BBL) ; #if $unicodebbl;
print BBL $BBL;
print "Output to $bblfile\n";
close BBL;

