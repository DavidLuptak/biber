package Biber;
use strict;
use warnings;
use Carp;
use IO::File;
use File::Spec;
use Encode;
use POSIX qw( locale_h ); # for sorting with built-in "sort"
use IPC::Cmd qw( can_run run );
use Cwd qw( abs_path );
use Biber::Config;
use Biber::Constants;
use List::Util qw( first );
use Biber::Internals;
use Biber::Entries;
use Biber::Entry;
use Biber::Entry::Name;
use Biber::Utils;
use LaTeX::Decode;
use Storable qw( dclone );
use Log::Log4perl qw( :no_extra_logdie_message );
use base 'Biber::Internals';
use Config::General qw( ParseConfig );
use Data::Dump;
our @ISA;

=encoding utf-8

=head1 NAME

Biber - main module for biber, a bibtex replacement for users of biblatex

=head1 VERSION

Version 0.5.2

=cut

our $VERSION = '0.5.2';

=head1 SYNOPSIS

    use Biber;

    my $biber = Biber->new();
    $biber->parse_auxfile("example.aux");
    $biber->prepare;
    $biber->print_to_bbl("example.bbl");

=cut

my $logger = Log::Log4perl::get_logger('main');

=head1 METHODS

=head2 new

    Initialize the Biber object, optionally passing named options as arguments.

    my $biber = Biber->new( fastsort => 1, datafile => 'biblatex.xml', outfile => 'test.bbl' );

=cut

sub new {
  my ($class, %opts) = @_;
  my $self = bless {}, $class;

  # Set up config object. There is only one per Biber object instance so
  # it is all class methods
  if (defined $opts{configfile}) {
    Biber::Config->_initopts( $opts{configfile} );
  } else {
    Biber::Config->_initopts(undef, $opts{noconf});
  }
  if (%opts) {
    foreach (keys %opts) {
      Biber::Config->setcmdlineoption($_, $opts{$_});
    }
  }
  $self->{bib} = new Biber::Entries;
  return $self;
}

=head2 citekeys

    my @citekeys = $biber->citekeys;

    Returns the array of all citation keys currently registered by Biber.

=cut

sub citekeys {
  my $self = shift;
  if ( $self->{citekeys} ) {
    return @{ $self->{citekeys} }
  } else {
    return ();
  }
}

=head2 orig_order_citekeys

    my @orig_order_citekeys = $biber->orig_order_citekeys;

    Returns the array of all citation keys currently registered by Biber
    guaranteed to be in the order they were cited.

=cut

sub orig_order_citekeys {
  my $self = shift;
  if ( $self->{orig_order_citekeys} ) {
    return @{ $self->{orig_order_citekeys} }
  } else {
    return ();
  }
}


=head2 has_citekey

    $biber->has_citekey($key)

    Returns true when $key is registered in the $biber object (case-insensitive)

=cut

sub has_citekey {
  my ($self, $key) = @_;
  return defined ( first { lc($_) eq lc($key) } $self->citekeys ) ? 1 : 0;
}

=head2 add_citekey

    $biber->add_citekey($key)

    Adds citekey $key to the $biber object

=cut

sub add_citekey {
  my ($self, $key) = @_;
  return if $self->has_citekey($key);
  my @citekeys = $self->citekeys;
  my @orig_order_citekeys = $self->orig_order_citekeys;
  $self->{citekeys} = [@citekeys, $key];
  $self->{orig_order_citekeys} = [@orig_order_citekeys, $key];
  return;
}

=head2 del_citekey

    $biber->del_citekey($key)

    Removes citekey $key from the $biber object (case-insensitive)

=cut

sub del_citekey {
  my ($self, $key) = @_;
  return unless $self->has_citekey($key);
  my @origkeys = $self->citekeys;
  my @newkeys = grep { lc($_) ne lc($key) } @origkeys;
  $self->{citekeys} = [@newkeys];
  return
}

=head2 bibentry

    my $bibentry = $biber->bibentry($citekey);

    Returns a Biber::Entry object for the given citation key

=cut

sub bibentry {
  my ($self, $key) = @_;
  $key = lc($key);
  return $self->bib->entry($key);
}

=head2 bib

    Return a Biber::Entries object which encapsulates all bibliographic data

=cut

sub bib {
  my $self = shift;
  if ( $self->{bib} ) {
    return $self->{bib};
  }
  else {
    return;
  }
}

=head2 shorthands

    Returns the list of all shorthands.

=cut

sub shorthands {
  my $self = shift;
  if ( $self->{shorthands} ) {
    return @{ $self->{shorthands} }
  } else {
    return;
  }
}

sub _addshorthand {
  my ($self, $key) = @_;
  # Don't add to los if skiplos is set for entry
  if (Biber::Config->getblxoption('skiplos', undef, $key)) {
    return;
  }
  my @los;
  if ( $self->shorthands ) {
    @los = $self->shorthands;
  }
  else {
    @los = ();
  }
  push @los, $key;
  $self->{shorthands} = [ @los ];
  return;
}


=head2 parse_auxfile

    Read the .aux file generated by LaTeX, identify all citekeys and configuration
    parameters, and store them in the Biber object.

=cut

sub parse_auxfile {

  my $self = shift;
  my $auxfile = shift;
  my @bibdatafiles = ();
  if (Biber::Config->getoption('bibdata')) {
    @bibdatafiles = @{ Biber::Config->getoption('bibdata') }
  };

  my @auxcitekeys = $self->citekeys;

  $logger->logcroak("Cannot find file '$auxfile'!") unless -f $auxfile;
  $logger->logcroak("File '$auxfile' is not an .aux file!") unless $auxfile =~ m/\.aux$/;

  my $aux = new IO::File "<$auxfile" or $logger->logcroak("Failed to open $auxfile : $!");

  my $ctrl_file = "";

  local $/ = "\n";

  $logger->info("Reading $auxfile");

  while (<$aux>) {

    if ( $_ =~ /^\\bibdata/ ) {

      # There can be more than one bibdata file!
      # We can parse many bib and/or xml files
      # Datafile given as option -d should be parsed first, then the other ones
      (my $bibdatastring) = $_ =~ m/^\\bibdata{ #{ <- for balancing brackets in vim
                                               ([^}]+)
}/x;

      my @tmp = split/,/, $bibdatastring;

      $ctrl_file = $auxfile;
      $ctrl_file =~ s/\.aux\z//xms;

      $logger->debug("control file is $ctrl_file.bcf");

      if (defined $bibdatafiles[0]) {

        push (@bibdatafiles, @tmp);

      }
      else {

        @bibdatafiles = @tmp;

      }
      Biber::Config->setoption('bibdata', [ @bibdatafiles ]);
    }

    if ( $_ =~ /^\\citation/ ) {
      m/^\\citation{ #{ for readability in vim
                          ([^}]+)
}/x;
      if ( $1 eq '*' ) {

        Biber::Config->setoption('allentries', 1);

        $logger->info("Processing all citekeys");

        # we stop reading the aux file as soon as we encounter \citation{*}
        last;

      }
      elsif ( not Biber::Config->get_seenkey($1) ) {
        push @auxcitekeys, decode_utf8($1);
        Biber::Config->incr_seenkey($1);
      }
      elsif ( Biber::Config->get_keycase($1) ne $1) {
        $logger->warn("Case mismatch error between cite keys $1 and " . Biber::Config->get_keycase($1));
        $logger->warn("I'm skipping whatever remains of this command");
        $self->{warnings}++;
        next;
      }
    }
  }

  $self->parse_ctrlfile($ctrl_file) if $ctrl_file;

  unless (@bibdatafiles) {
    $logger->logcroak("No database is provided in the file '$auxfile'! Exiting")
  }

  unless (Biber::Config->getoption('allentries') or @auxcitekeys) {
    $logger->logcroak("The file '$auxfile' does not contain any citations!")
  }

  $logger->info("Found ", $#auxcitekeys+1 , " citekeys in aux file")
    unless Biber::Config->getoption('allentries') ;

  if (Biber::Config->getoption('debug')) {
    my @debug_auxcitekeys = sort @auxcitekeys;
    unless (Biber::Config->getoption('allentries')) {
      $logger->debug("The citekeys are:\n", "@debug_auxcitekeys", "\n");
    }
  }

  $self->{citekeys} = [ @auxcitekeys ];

  # Preserve the original cite order for citekeys sort
  $self->{orig_order_citekeys} = [ @auxcitekeys ];

  return;
}


=head2 parse_ctrlfile

    This method is automatically called by parse_auxfile. It reads the control file
    generated by biblatex to figure out the various biblatex options.
    See Constants.pm for defaults and example of the data structure being built here.

=cut

sub parse_ctrlfile {
  my ($self, $ctrl_file) = @_;

  $logger->warn("Cannot find control file '$ctrl_file.bcf'! - did you pass the \"backend=biber\" option to BibLaTeX?") unless -f "$ctrl_file.bcf";

  # Validate if asked to
  if (Biber::Config->getoption('validate')) {
    require XML::LibXML;

    # Set up XML parser
    my $CFxmlparser = XML::LibXML->new();
    $CFxmlparser->line_numbers(1); # line numbers for more informative errors

    # Set up schema
    my $CFxmlschema;

    # we assume that the schema files are in the same dir as Biber.pm:
    (undef, my $biber_path, undef) = File::Spec->splitpath( $INC{"Biber.pm"} );
    ## NB the following also works, but the above approach is better
   #my $bcfpath = first { -f File::Spec->catfile($_, 'Biber', 'bcf.rng') } @INC;
    my $bcf_rng = File::Spec->catfile($biber_path, 'Biber', 'bcf.rng');

    if (-f $bcf_rng) {
      $CFxmlschema = XML::LibXML::RelaxNG->new( location => $bcf_rng )
    } else {
      $logger->warn("Cannot find XML::LibXML::RelaxNG schema. Skipping validation : $!");
    }

    # basic parse and XInclude processing
    my $CFxp = $CFxmlparser->parse_file("$ctrl_file.bcf");

    # XPath context
    my $CFxpc = XML::LibXML::XPathContext->new($CFxp);
    $CFxpc->registerNs('bcf', 'https://sourceforge.net/projects/biblatex');

    # Validate against schema. Dies if it fails.
    if ($CFxmlschema) {
      eval { $CFxmlschema->validate($CFxp) };
      if (ref($@)) {
        $logger->debug( $@->dump() );
        $logger->logcroak("BibLaTeX control file \"$ctrl_file.bcf\" FAILED TO VALIDATE\n$@");
      }
      elsif ($@) {
        $logger->logcroak("BibLaTeX control file \"$ctrl_file.bcf\" FAILED TO VALIDATE\n$@");
      }
      else {
        $logger->info("BibLaTeX control file \"$ctrl_file.bcf\" validates");
      }
    }

  }

  my $ctrl = new IO::File "<$ctrl_file.bcf"
    or $logger->logcroak("Cannot open $ctrl_file.bcf: $!");

  $logger->info("Reading $ctrl_file.bcf");

  # Read control file
  require XML::LibXML::Simple;
  my $bcfxml = XML::LibXML::Simple::XMLin($ctrl, 'ForceArray' => 1, 'NsStrip' => 1, KeyAttr => []);

  my $controlversion = $bcfxml->{'version'};
  Biber::Config->setblxoption('controlversion', $controlversion);
  $logger->warn("Warning: You are using biblatex version $controlversion :
biber is more likely to work with version $BIBLATEX_VERSION.")
    unless substr($controlversion, 0, 3) eq $BIBLATEX_VERSION;

# Look at control file and populate our main data structure with its information

  # OPTIONS
  foreach my $bcfopts (@{$bcfxml->{options}}) {

    # Biber options
    if (lc($bcfopts->{component}) eq 'biber') {

      # Global options
      if (lc($bcfopts->{type}) eq 'global') {
        foreach my $bcfopt (@{$bcfopts->{option}}) {
          unless (Biber::Config->getcmdlineoption($bcfopt->{key})) { # already set on cmd line
            if (lc($bcfopt->{type}) eq 'singlevalued') {
              Biber::Config->setoption($bcfopt->{key}, $bcfopt->{value});
            } elsif (lc($bcfopt->{type}) eq 'multivalued') {
              Biber::Config->setoption($bcfopt->{key},
                [ map {$_->{content}} sort {$a->{order} <=> $b->{order}} @{$bcfopt->{value}} ]);
            }
          }
        }
      }
    }

    # BibLaTeX options
    if (lc($bcfopts->{component}) eq 'biblatex') {

      # Global options
      if (lc($bcfopts->{type}) eq 'global') {
        foreach my $bcfopt (@{$bcfopts->{option}}) {
          if (lc($bcfopt->{type}) eq 'singlevalued') {
            Biber::Config->setblxoption($bcfopt->{key}, $bcfopt->{value});
          } elsif (lc($bcfopt->{type}) eq 'multivalued') {
            Biber::Config->setblxoption($bcfopt->{key},
              [ map {$_->{content}} sort {$a->{order} <=> $b->{order}} @{$bcfopt->{value}} ]);
          }
        }
      }

      # Entrytype options
      else {
        my $entrytype = $bcfopts->{type};
        foreach my $bcfopt (@{$bcfopts->{option}}) {
          if (lc($bcfopt->{type}) eq 'singlevalued') {
            Biber::Config->setblxoption($bcfopt->{key}, $bcfopt->{value}, 'PER_TYPE', $entrytype);
          } elsif (lc($bcfopt->{type}) eq 'multivalued') {
            Biber::Config->setblxoption($bcfopt->{key},
              [ map {$_->{content}} sort {$a->{order} <=> $b->{order}} @{$bcfopt->{value}} ],
              'PER_TYPE',
              $entrytype);
          }
        }
      }
    }
  }

  # SORTING schemes
  foreach my $sortschemes (@{$bcfxml->{sorting}}) {
    my $sorting_label = [];
    my $sorting_final = [];
    foreach my $sort (sort {$a->{order} <=> $b->{order}} @{$sortschemes->{sort}}) {
      my $sortingitems_label;
      my $sortingitems_final;

      # Determine which sorting pass(es) to include the item in
      my $whichpass = ($sort->{pass} or 'both');

      # Generate sorting pass structures
      foreach my $sortitem (sort {$a->{order} <=> $b->{order}} @{$sort->{sortitem}}) {
        my $sortitemattributes = {};
        if (defined($sortitem->{final})) { # Found a sorting short-circuit marker
          $sortitemattributes->{final} = 1;
        }
        if (defined($sortitem->{substring_side})) { # Found sorting substring side attribute
          $sortitemattributes->{substring_side} = $sortitem->{substring_side};
        }
        if (defined($sortitem->{substring_width})) { # Found sorting substring length attribute
          $sortitemattributes->{substring_width} = $sortitem->{substring_width};
        }
        if (defined($sortitem->{pad_width})) { # Found sorting pad length attribute
          $sortitemattributes->{pad_width} = $sortitem->{pad_width};
        }
        if (defined($sortitem->{pad_char})) { # Found sorting pad char attribute
          $sortitemattributes->{pad_char} = $sortitem->{pad_char};
        }
        if (defined($sortitem->{pad_side})) { # Found sorting pad side attribute
          $sortitemattributes->{pad_side} = $sortitem->{pad_side};
        }
        if (defined($sortitem->{sort_direction})) { # Found sorting direction attribute
          $sortitemattributes->{sort_direction} = $sortitem->{sort_direction};
        }

# No pass specified, sortitem is included in both sort passes
# Note that we're cloning the sortitemattributes object so as not to have pointers
# from one structure to the other
        if (lc($whichpass) eq 'both') {
          push @{$sortingitems_label}, {$sortitem->{content} => $sortitemattributes};
          push @{$sortingitems_final}, {$sortitem->{content} => dclone($sortitemattributes)};
        }

        # "label" specified, sortitem is included only on "label" sort pass
        elsif (lc($whichpass) eq 'label') {
          push @{$sortingitems_label}, {$sortitem->{content} => $sortitemattributes};
        }

        # "final" specified, sortitem is included only on "final" sort pass
        elsif (lc($whichpass) eq 'final') {
          push @{$sortingitems_final}, {$sortitem->{content} => $sortitemattributes};
        }
      }

  # Only push a sortitem if defined. If the item has a conditional "pass"
  # attribute, it may be ommitted in which case we don't want an empty array ref
  # pushing
      push @{$sorting_label}, $sortingitems_label if defined($sortingitems_label);
      push @{$sorting_final}, $sortingitems_final if defined($sortingitems_final);
    }
    if (lc($sortschemes->{type}) eq 'global') {
      Biber::Config->setblxoption('sorting_label', $sorting_label);
      Biber::Config->setblxoption('sorting_final', $sorting_final);
    }
    else {
      Biber::Config->setblxoption('sorting_label', $sorting_label, 'PER_TYPE', $sortschemes->{type});
      Biber::Config->setblxoption('sorting_final', $sorting_final, 'PER_TYPE', $sortschemes->{type});
    }
  }

  # BIB SECTIONS
  foreach my $section (@{$bcfxml->{section}}) {
    my @current = Biber::Config->getblxsection($section->{number});
    push @current, @{$section->{citekey}};
    Biber::Config->setblxsection($section->{number}, \@current);
  }
  return;
}

#=====================================================
# Parse BIB file
#=====================================================

=head2 parse_bibtex

    This is a wrapper method to parse a bibtex database. If available it will
    pass the job to Text::BibTeX via Biber::BibTeX, otherwise it relies on a
    slower pure Perl parser implemented in Biber::BibTeX::PRD.

    $biber->parse_bibtex("data.bib");

=cut

sub parse_bibtex {
  my ($self, $filename) = @_;

  $logger->info("Processing bibtex file $filename");

  my @localkeys = ();

  my $ufilename = "$filename.utf8";

  if ( not Biber::Config->getoption('unicodebib') and
    Biber::Config->getoption('unicodebbl') ) {
    require LaTeX::Decode;
    require File::Slurp;
    my $ubib = IO::File->new( $ufilename, ">:utf8" );

    # $ubib->binmode(':utf8');

    my $mode = "";

#        if ( Biber::Config->getoption('bibencoding') ) {
#            $mode = ':encoding(' . Biber::Config->getoption('bibencoding') . ')';
#        } else {
#            $mode = "";
#        };

    my $infile = IO::File->new( $filename, "<$mode" );

    my $buf    = File::Slurp::read_file($infile)
      or $logger->logcroak("Can't read $filename");

    if ( Biber::Config->getoption('bibencoding') ) {
      $buf = decode(Biber::Config->getoption('bibencoding'), $buf)
    };

    print $ubib LaTeX::Decode::latex_decode($buf)
      or $logger->logcroak("Can't write to $ufilename : $!");
    $ubib->close or $logger->logcroak("Can't close filehandle to $ufilename: $!");

    $filename  = $ufilename;

    Biber::Config->setoption('unicodebib', 1);
  }

  unless ( eval "require Text::BibTeX; 1" ) {
    Biber::Config->setoption('useprd', 1);
  }

  unless ( Biber::Config->getoption('useprd') ) {

    require Biber::BibTeX;
    push @ISA, 'Biber::BibTeX';

    @localkeys = $self->_text_bibtex_parse($filename);

  }
  else {

    require Biber::BibTeX::PRD;
    push @ISA, 'Biber::BibTeX::PRD';

    $logger->info("Using a Parse::RecDescent parser...");

    # we only add this warning if the bib file is larger than 20KB
    if (-s $filename > 20000 ) {
      $logger->warn("Note that it can be very slow with large bib files!\n",
        "You are advised to install Text::BibTeX for faster processing!");
    };

    @localkeys = $self->_bibtex_prd_parse($filename);
  }

  unlink $ufilename if -f $ufilename;

  if (Biber::Config->getoption('allentries')) {
    map { Biber::Config->incr_seenkey($_) } @localkeys
  }

  my $bibentries = $self->bib;

# if allentries, push all bibdata keys into citekeys (if they are not already there)
# Can't just make citekeys = bibdata keys as this loses information about citekeys
# that are missing data entries.
  if (Biber::Config->getoption('allentries')) {
    foreach my $bibkey ($bibentries->sorted_keys) {
      $self->add_citekey($bibkey) unless $self->has_citekey($bibkey);
    }
  }

  return;

}

=head2 parse_biblatexml

    $biber->parse_biblatexml('data.xml');

    Parse a database in the BibLaTeXML format with Biber::BibLaTeXML (via
    XML::LibXML). If the suffix is dbxml, then the database is assumed to
    be stored in a Berkeley DBXML container and will be queried through the
    Sleepycat::DbXml interface.

=cut

sub parse_biblatexml {
  my ($self, $xml) = @_;
  require Biber::BibLaTeXML;
  push @ISA, 'Biber::BibLaTeXML';
  $self->_parse_biblatexml($xml);
}

=head2 process_missing

   Check for missing citation keys

=cut

sub process_missing {
  my $self = shift;
  my $bibentries = $self->bib;
  $logger->debug("Checking for missing citekeys");
  foreach my $citekey ( $self->citekeys ) {
    unless ( $bibentries->entry_exists($citekey) ) {
      $logger->warn("I didn't find a database entry for '$citekey'");
      $self->{warnings}++;
      $self->del_citekey($citekey);
      next;
    }
  }
}

=head2 process_sets_and_crossrefs

    $biber->process_sets_and_crossrefs

    This does three things:
    1. Ensures that all citekeys that are within entry sets will be output in the bbl.
    2. Ensures proper inheritance of data from cross-references.
    3. Ensures that crossrefs that are directly cited or cross-referenced
       at least $mincrossrefs times are included in the bibliography.

    This method is automatically called by C<prepare>.

=cut

sub process_sets_and_crossrefs {
  my $self = shift;
  $logger->debug("Processing entry sets and crossrefs");
  foreach my $citekey ($self->citekeys) {
    my $be = $self->bibentry($citekey);
    if (lc($be->get_field('entrytype')) eq 'set') {
      my @inset_keys = split /\s*,\s*/, $be->get_field('entryset');
      foreach my $inset_key (@inset_keys) {
        $logger->debug("  Adding inset entry '$inset_key' to the citekeys");
        $self->add_citekey($inset_key);
      }
    }
    if ($be->get_field('crossref')) {
      my $crossrefkey = $be->get_field('crossref');
      my $parent = $self->bibentry($crossrefkey);
      $logger->debug("  Entry $citekey inheriting fields from parent $crossrefkey");
      $be->inherit_from($parent);
    }
  }
  # We make sure that crossrefs that are directly cited or cross-referenced
  # at least $mincrossrefs times are included in the bibliography.
  # All crossrefs that are kept in "crossrefkeys" will be skipped
  # when writing the bbl output.
  foreach my $k ( @{Biber::Config->get_crossrefkeys} ) {
    if ( $self->has_citekey($k) or
      Biber::Config->get_crossrefkey($k) >= Biber::Config->getoption('mincrossrefs') ) {
      $logger->debug("Removing unneeded crossrefkey $k");
      Biber::Config->del_crossrefkey($k);
    }
  }
}

=head2 postprocess

    Various postprocessing operations, mostly to generate special fields for
    biblatex. This method is automatically called by C<prepare>.
    Here we parse names, generate the "namehash" and the strings for
    "labelname", "labelyear", "labelalpha", "sortstrings", etc.

=cut

sub postprocess {
  my $self = shift;
  my $bibentries = $self->bib;
  foreach my $citekey ( $self->citekeys ) {
    $logger->debug("Postprocessing entry '$citekey'");

    # Postprocess dates
    $self->postprocess_dates($citekey);

    # post process "set" entries:
    $self->postprocess_sets($citekey);

    # generate labelname name
    $self->postprocess_labelname($citekey);

    # generate labelyear name
    $self->postprocess_labelyear($citekey);

    # generate namehash,fullhash
    $self->postprocess_hashes($citekey);

    # track labelname/year combinations
    $self->postprocess_labelnameyear($citekey);

    # generate labelalpha information
    $self->postprocess_labelalpha($citekey);

    # track shorthands
    $self->postprocess_shorthands($citekey);

    # Set default type for patens entries
    $self->postprocess_patents($citekey);

    # first-pass sorting to generate basic labels
    $self->postprocess_sorting_firstpass($citekey);
  }

  $logger->debug("Finished postprocessing entries");

  return;
}

=head2 postprocess_dates

    Here we do some sanity checking on date fields and then parse the
    *DATE fields into their components, collecting any warnings to put
    into the .bbl later

    Quick check on YEAR and MONTH fields which are the only date related
    components which can be directly set and therefore don't go through
    the date parsing below

=cut

sub postprocess_dates {
  my $self = shift;
  my $citekey = shift;
  my $bibentries = $self->bib;
  my $be = $bibentries->entry($citekey);

  # Both DATE and YEAR specified
  if ($be->get_field('date') and $be->get_field('year')) {
    $logger->warn("Field conflict - both 'date' and 'year' used - ignoring field 'year' in '$citekey'");
    $self->{warnings}++;
    $be->add_warning("Field conflict - both 'date' and 'year' used - ignoring field 'year'");
    $be->del_field('year');
  }

  # Both DATE and MONTH specified
  if ($be->get_field('date') and $be->get_field('month')) {
    $logger->warn("Field conflict - both 'date' and 'month' used - ignoring field 'month' in '$citekey'");
    $self->{warnings}++;
    $be->add_warning("Field conflict - both 'date' and 'month' used - ignoring field 'month'");
    $be->del_field('month');
  }

  # MONTH must be an integer - YEAR doesn't have to be to allow for things like
  # "in press" which sometimes need an extrayear disambiguator (in APA styles for example)
  if ($be->get_field('month') and $be->get_field('month') !~ /\A\d+\z/xms) {
    $logger->warn("Invalid format of field 'month' - ignoring field in entry '$citekey'");
    $self->{warnings}++;
    $be->add_warning("Invalid format of field 'month' - ignoring field");
    $be->del_field('month');
  }

  # Generate date components from *DATE fields
  foreach my $datetype ('', 'orig', 'event', 'url') {
    if ($be->get_field($datetype . 'date')) {
      my $date_re = qr|(\d{4})(?:-(\d{2}))?(?:-(\d{2}))?|xms;
      if ($be->get_field($datetype . 'date') =~ m|\A$date_re(/)?(?:$date_re)?\z|xms) {
        $be->set_field($datetype . 'year', $1) if $1;
        $be->set_field($datetype . 'month', $2) if $2;
        $be->set_field($datetype . 'day', $3) if $3;
        $be->set_field($datetype . 'endmonth', $6) if $6;
        $be->set_field($datetype . 'endday', $7) if $7;
        if ($4 and $5) {        # normal range
          $be->set_field($datetype . 'endyear', $5);
        } elsif ($4 and not $5) { # open ended range - endyear is defined but empty
          $be->set_field($datetype . 'endyear', '');
        }
      } else {
        $logger->warn("Invalid format of field '" . $datetype . 'date' . "' - ignoring field in entry '$citekey'");
        $self->{warnings}++;
        $be->add_warning("Invalid format of field '" . $datetype . 'date' . "' - ignoring field");
        $be->del_field($datetype . 'date');
      }
    }
  }

  # Now more carefully check the individual date components
  my $opt_dm = qr/(?:event|orig|url)?(?:end)?/xms;
  foreach my $dcf (@DATECOMPONENTFIELDS) {
    my $bad_format = '';
    if ($be->get_field($dcf)) {

      # months must be in right range
      if ($dcf =~ /\A$opt_dm month\z/xms) {
        unless ($be->get_field($dcf) >= 1 and $be->get_field($dcf) <= 12) {
          $bad_format = 1;
        }
      }

      # days must be in right range
      if ($dcf =~ /\A$opt_dm day\z/xms) {
        unless ($be->get_field($dcf) >= 1 and $be->get_field($dcf) <= 31) {
          $bad_format = 1;
        }
      }
      if ($bad_format) {
        $logger->warn("Value out bounds for field/date component '$dcf' - ignoring in entry '$citekey'");
        $self->{warnings}++;
        $be->add_warning("Value out of bounds for field/date component '$dcf' - ignoring");
        $be->del_field($dcf);
      }
    }
  }
}


=head2 postprocess_sets

    Postprocess set entries

    Checks for common set errors and enforces 'dataonly' for set members

=cut

sub postprocess_sets {
  my $self = shift;
  my $citekey = shift;
  my $bibentries = $self->bib;
  my $be = $bibentries->entry($citekey);
  if ( $be->get_field('entrytype') eq 'set' ) {
    my @entrysetkeys = split /\s*,\s*/, $be->get_field('entryset');

    # Enforce Biber parts of virtual "dataonly" for set members
    foreach my $member (@entrysetkeys) {
      Biber::Config->setblxoption('skiplab', 1, 'PER_ENTRY', $member);
      Biber::Config->setblxoption('skiplos', 1, 'PER_ENTRY', $member);
    }

    unless (@entrysetkeys) {
      $logger->warn("No entryset found for entry $citekey of type 'set'");
      $self->{warnings}++;
    }
    if ( $be->get_field('crossref')
      and ( $be->get_field('crossref') ne $entrysetkeys[0] ) ) {

      $logger->warn( "Problem with entry $citekey :\n"
          . "\tcrossref ("
          . $be->get_field('crossref')
          . ") should be identical to the first element of the entryset"
        );
      $self->{warnings}++;
      $be->set_field('crossref', $entrysetkeys[0]);

    }
    elsif ( not $be->get_field('crossref') ) {
      $logger->warn("Adding missing field 'crossref' to entry $citekey");
      $be->set_field('crossref', $entrysetkeys[0]);
    }
  }
}

=head2 postprocess_labelname

    Generate labelname information. Fields set are:

    * labelnamename - the name of the labelname field to use
    * labelnamenamefullhash - the name of the labelname field to use for
                              fulhash generation.

    We can retreive the actual labelname value later with:

    $entry->get_field($entry->get_field('labelnamename))

    It's neat this way as we often need to know what the labelname field is
    as well as it's actual string value

=cut

sub postprocess_labelname {
  my $self = shift;
  my $citekey = shift;
  my $bibentries = $self->bib;
  my $be = $bibentries->entry($citekey);
  my $lnamescheme = Biber::Config->getblxoption('labelname', $be->get_field('entrytype'), $citekey);

  # First we set the normal labelname name
  foreach my $ln ( @{$lnamescheme} ) {
    my $lnameopt;
    if ( $ln =~ /\Ashort(.+)\z/ ) {
      $lnameopt = $1;
    } else {
      $lnameopt = $ln;
    }
    if ($be->get_field($ln) and
      Biber::Config->getblxoption("use$lnameopt", $be->get_field('entrytype'), $citekey ) ) {
      $be->set_field('labelnamename', $ln);
      last;
    }
  }

  # Then we loop again to set the labelname name for the fullhash generation code
  # This is because fullhash generation ignores SHORT* fields (section 4.2.4.1, BibLaTeX
  # manual)
  foreach my $ln ( @{$lnamescheme} ) {
    if ( $ln =~ /\Ashort(.+)\z/ ) {
      next;
    }
    if ($be->get_field($ln) and
      Biber::Config->getblxoption("use$ln", $be->get_field('entrytype'), $citekey ) ) {
      $be->set_field('labelnamenamefullhash', $ln);
      last;
    }
  }

  unless ( $be->get_field('labelnamename') ) {
    $logger->debug("Could not determine the labelname of entry $citekey");
  }
}

=head2 postprocess_labelyear

    Generate labelyear
    Here, "labelyearname" is the name of the labelyear field
    and "labelyear" is the actual copy of the relevant field

=cut

sub postprocess_labelyear {
  my $self = shift;
  my $citekey = shift;
  my $bibentries = $self->bib;
  my $be = $bibentries->entry($citekey);
  my $lyearscheme = Biber::Config->getblxoption('labelyear', $be->get_field('entrytype'), $citekey);

  if ($lyearscheme) {
    if (Biber::Config->getblxoption('skiplab', undef, $citekey)) {
      return;
    }
    # make sure we gave the correct data type:
    $logger->logcroak("Invalid value for option labelyear: $lyearscheme\n")
      unless ref $lyearscheme eq 'ARRAY';
    foreach my $ly ( @{$lyearscheme} ) {
      if ($be->get_field($ly)) {
        $be->set_field('labelyearname', $ly);
        last;
      }
    }

    unless ( $be->get_field('labelyearname') ) {
      $logger->debug("Could not determine the labelyearname of entry $citekey");
    }
  }
}

=head2 postprocess_hashes

    Generate namehash and fullhash

=cut

sub postprocess_hashes {
  my $self = shift;
  my $citekey = shift;
  my $bibentries = $self->bib;
  my $be = $bibentries->entry($citekey);
  my $bee = $be->get_field('entrytype');
  my $namehash = ''; # biblatex namehash field (manual, section 4.2.4.1)
  my $fullhash = ''; # biblatex fullhash field (manual, section 4.2.4.1)
  my $nameid   = '';

  # namehash is generated from the labelname
  if (my $lname = $be->get_field('labelnamename')) {
    if ($be->get_field($lname)) {
      $namehash .= $self->_getnameinitials($citekey, $be->get_field($lname));
      $nameid .= makenameid($be->get_field($lname));
    }
  }
  # fullhash is generated from the labelname but ignores SHORT* fields and
  # maxnames/minnames settings
  if (my $lnamefh = $be->get_field('labelnamenamefullhash')) {
    if ($be->get_field($lnamefh)) {
      $fullhash .= $self->_getallnameinitials($citekey, $be->get_field($lnamefh));
    }
  }

  # After the initial generation of namehash and fullhash, we have to append
  # a suffix as they must be unique. It is possible that different entries have
  # the same hashes at this stage. For example:

  # AUTHOR = {Fred Grimble and Bill Bullter} = "FGBB"
  # AUTHOR = {Frank Garby and Brian Blunkley} = "FGBB"

  my $hashsuffix = 1;

  # First, check to see if we've already seen this exact name before
  if (Biber::Config->get_namehashcount($namehash, $nameid)) {
    # If we have, our suffix is already known
    $hashsuffix = Biber::Config->get_namehashcount($namehash, $nameid);
  }
  # Otherwise, if the namehash already exists, we'll make a new entry with a new suffix
  elsif (Biber::Config->namehashexists($namehash)) {
    # Count the suffixes already defined ...
    my $count = Biber::Config->get_numofnamehashes($namehash);
    # ... add one to the number ...
    $hashsuffix = $count + 1;
    # ... and define a new suffix for that name
    Biber::Config->set_namehashcount($namehash, $nameid, $hashsuffix);
  }
  # No entry for the namehash at all so make a new one, a new name and suffix
  else {
    Biber::Config->del_namehash($namehash);
    Biber::Config->set_namehashcount($namehash, $nameid, 1);
  }

  # Now append the suffices, making the hashes unique
  $namehash .= $hashsuffix;
  $fullhash .= $hashsuffix;

  # Set the hashes
  $be->set_field('namehash', $namehash);
  $be->set_field('fullhash', $fullhash);

  Biber::Config->incr_seennamehash($fullhash);
}


=head2 postprocess_labelnameyear

    Track labelname/year combination

=cut

sub postprocess_labelnameyear {
  my $self = shift;
  my $citekey = shift;
  my $bibentries = $self->bib;
  my $be = $bibentries->entry($citekey);
  # This is all used to generate extrayear/extralpha and the rules for this are:
  # * Generate labelname/year combination for tracking extrayear
  # * If there is no labelname to use, use empty string
  # * If there is no labelyear to use, use empty string
  # * Don't increment the seennameyear count if either name or year string is empty
  #   (see code in incr_nameyear method).
  my $name_string;
  if ($be->get_field('labelnamename')) {
    $name_string = $self->_namestring($citekey, $be->get_field('labelnamename'));
  }
  else {
    $name_string = '';
  }
  my $year_string;
  if ($be->get_field('labelyearname')) {
    $year_string = $be->get_field($be->get_field('labelyearname'));
  }
  elsif ($be->get_field('year')) {
    $year_string = $be->get_field('year');
  }
  else {
    $year_string = '';
  }
  my $nameyear_string = $name_string . '0' . $year_string;
  Biber::Config->incr_seennameyear($name_string, $year_string);
  $be->set_field('nameyear', $nameyear_string);
}

=head2 postprocess_labelalpha

    Generate the labelalpha and also the variant for sorting

=cut

sub postprocess_labelalpha {
  my $self = shift;
  my $citekey = shift;
  my $bibentries = $self->bib;
  my $be = $bibentries->entry($citekey);
  # Don't add a label if skiplab is set for entry
  if (Biber::Config->getblxoption('skiplab', undef, $citekey)) {
    return;
  }
  if ( Biber::Config->getblxoption('labelalpha', $be->get_field('entrytype'), $citekey) ) {
    my $label;
    my $sortlabel;

    if ( $be->get_field('shorthand') ) {
      $sortlabel = $label = $be->get_field('shorthand');
    } else {
      if ( $be->get_field('label') ) {
        $sortlabel = $label = $be->get_field('label');
      } elsif ( $be->get_field('labelnamename') and $be->get_field($be->get_field('labelnamename'))) {
        ( $label, $sortlabel ) =
          @{ $self->_getlabel( $citekey, $be->get_field('labelnamename') ) };
      } else {
        $sortlabel = $label = '';
      }
      if ( my $year = $be->get_field('year') ) {
        my $yr;
        # Make "in press" years look nice in alpha styles
        if ($year =~ m/\A\s*in\s*press\s*\z/ixms) {
          $yr = 'ip';
        }
        # Normal year
        else {
          $yr = substr $year, 2, 2;
        }
        $label     .= $yr;
        $sortlabel .= $yr;
      }
    }
    $be->set_field('labelalpha', $label);
    $be->set_field('sortlabelalpha', $sortlabel);
  }
}

=head2 postprocess_shorthands

    Track shorthands

=cut

sub postprocess_shorthands {
  my $self = shift;
  my $citekey = shift;
  my $bibentries = $self->bib;
  my $be = $bibentries->entry($citekey);
  if ( $be->get_field('shorthand') ) {
    $self->_addshorthand($citekey);
  }
}

=head2 postprocess_patents

    Deal with patent entry defaults

=cut

sub postprocess_patents {
  my $self = shift;
  my $citekey = shift;
  my $bibentries = $self->bib;
  my $be = $bibentries->entry($citekey);
  if ( ( $be->get_field('entrytype') eq 'patent' ) and ( not $be->get_field('type') ) ) {
    $be->set_field('type', 'patent');
  }
}

=head2 postprocess_sorting_firstpass

    First pass of sorting information generation

=cut

sub postprocess_sorting_firstpass {
  my $self = shift;
  my $citekey = shift;
  my $bibentries = $self->bib;
  my $be = $bibentries->entry($citekey);
  $self->_generatesortstring( $citekey, Biber::Config->getblxoption('sorting_label', $be->get_field('entrytype'), $citekey));
}

=head2 generate_extras

    Generate extrayear and extraalpha

=cut

sub generate_extras {
  my $self = shift;
  my $bibentries = $self->bib;
  foreach my $citekey ($self->citekeys) {
    my $be = $bibentries->entry($citekey);
    my $nameyear = $be->get_field('nameyear');
    # Only generate extrayear if skiplab is not set.
    # Don't forget that skiplab is implied for set members
    unless (Biber::Config->getblxoption('skiplab', undef, $citekey)) {
      if (Biber::Config->get_seennameyear($nameyear) > 1) {
        Biber::Config->incr_seenlabelyear($nameyear);
        if (Biber::Config->getblxoption('labelyear', $be->get_field('entrytype'), $citekey) ) {
          $be->set_field('extrayear', Biber::Config->get_seenlabelyear($nameyear));
        }
        if (Biber::Config->getblxoption('labelalpha', $be->get_field('entrytype'), $citekey) ) {
          $be->set_field('extraalpha', Biber::Config->get_seenlabelyear($nameyear));
        }
      }
    }
  }
  return;
}

=head2 generate_final_sortinfo

    Generate final sort information

=cut

sub generate_final_sortinfo {
  my $self = shift;
  my $bibentries = $self->bib;
  foreach my $citekey ($self->citekeys) {
    my $be = $bibentries->entry($citekey);
    $self->_generatesortstring($citekey, Biber::Config->getblxoption('sorting_final', $be->get_field('entrytype'), $citekey));
  }
  return;
}

=head2 uniqueness

    Generate the uniqueness information needed when creating .bbl

=cut


sub uniqueness {
  my $self = shift;
  my $bibentries = $self->bib;
  # Generate uniqueness information according to this algorithm:
  # 1. Generate uniquename if uniquename option is set
  # 2. if (uniquelist has never run before OR step 1 changed any uniquename values) {
  #      goto step 3
  #    } else { goto step 5 }
  # 3. Completely regenerate uniquelist if uniquelist option is set
  # 4. if (step 3 changed any uniquelist values) {
  #      goto step 1
  #    } else { goto step 5 }
  # 5. Run extrayear generation if requested based on data as it stands after step 4
  # 6. Run singletitle generation if requested based on data as it stands after step 4

  # Set a flag for first uniquelist pass. This is a special case as we always want to run
  # at least one uniquelist pass if requested, regardless of unul_done global flag.
  my $first_ul_pass = 1;

  # Generate uniquename information, if requested
  while ('true') {
    unless (Biber::Config->get_unul_done) {
      Biber::Config->set_unul_changed(0); # reset state for global unul changed flag
      if (Biber::Config->getblxoption('uniquename', undef, undef)) {
        $self->create_uniquename_info;
        $self->generate_uniquename;
      }
    }
    else {
      last; # uniquename/uniquelist disambiguation is finished as nothing changed
    }
    # Generate uniquelist information, if requested
    # Always run uniquelist at least once, if requested
    if ($first_ul_pass or not Biber::Config->get_unul_done) {
      Biber::Config->set_unul_changed(0); # reset state for global unul changed flag
      if (Biber::Config->getblxoption('uniquelist', undef, undef)) {
        $first_ul_pass = 0; # Ignore special case when uniquelist has run once
        $self->create_uniquelist_info;
        $self->generate_uniquelist;
      }
    }
    else {
      last; # uniquename/uniquelist disambiguation is finished as nothing changed
    }
  }
  $self->generate_extras;
#  $self->generate_singletitle;
}


=head2 create_uniquename_info

    Gather the uniquename information as we look through the names

=cut


sub create_uniquename_info {
  my $self = shift;
  my $bibentries = $self->bib;

  # Reset uniquename information as we have to generate it again because uniquelist
  # information might have changed
  Biber::Config->reset_uniquenamecount;

  foreach my $citekey ( $self->citekeys ) {
    $logger->debug("Generating uniquename information for '$citekey'");
    my $be = $bibentries->entry($citekey);
    my $bee = $be->get_field('entrytype');
    my $namehash = $be->get_field('namehash');
    if (my $lname = $be->get_field('labelnamename')) {

      # First find out the maxnames setting for this namelist.
      my $ul = -1; # Not set
      if (defined($be->get_field($lname)->get_uniquelist)) {
        $ul = $be->get_field($lname)->get_uniquelist;
      }
      my $mn = Biber::Config->getblxoption('maxnames', $be->get_field('entrytype'), undef );
      # Set the index limit beyond which we don't look for disambiguating information
      my $localmaxnames = $ul > $mn ? $ul : $mn;

      # Note that we don't determine if a name is unique here -
      # we can't, were still processing entries at this point.
      # Here we are just recording seen combinations of:
      #
      # lastnames and how many hashes were generated from them (uniquename = 0)
      # lastnames+initials how many hashes were generated from them (uniquename = 1)
      # Full name and how many hashes were generated from them (uniquename = 2)
      #
      # Anything which has more than one combination for both of these would
      # be uniquename = 2 unless even the full name doesn't disambiguate
      # and then it is left at uniquename=0

      foreach my $name (@{$be->get_field($lname)->names}) {
        # We don't want to record disambiguation information for any names
        # that are hidden by a maxnames/uniquelist limit
        unless ($name->get_index > $localmaxnames) {
          my $lastname   = $name->get_lastname;
          my $nameinitstring = $name->get_nameinitstring;
          my $namestring = $name->get_namestring;

          # Record a uniqueness information entry for the lastname showing that
          # this lastname has been seen in the name with the namehash
          Biber::Config->add_uniquenamecount($lastname, $namestring);

          # Record a uniqueness information entry for the lastname+initials showing that
          # this lastname_initials has been seen in the name with the namehash
          Biber::Config->add_uniquenamecount($nameinitstring, $namestring);

          # Record a uniqueness information entry for the fullname
          # showing that this fullname has been seen in the name with the namehash
          Biber::Config->add_uniquenamecount($namestring, $namestring);
        }
      }
    }
  }
}

=head2 generate_uniquename

   Generate the per-name uniquename values using the information
   harvested by create_uniquename_info()

=cut

sub generate_uniquename {
  my $self = shift;
  my $bibentries = $self->bib;
  my $un = Biber::Config->getblxoption('uniquename', undef, undef);

  # Now use the information to set the actual uniquename information
  foreach my $citekey ( $self->citekeys ) {
    $logger->debug("Setting uniquename for '$citekey'");
    my $be = $bibentries->entry($citekey);
    my $bee = $be->get_field('entrytype');
    my $namehash = $be->get_field('namehash');

    if (my $lname = $be->get_field('labelnamename')) {
      foreach my $name (@{$be->get_field($lname)->names}) {
        my $lastname   = $name->get_lastname;
        my $nameinitstring = $name->get_nameinitstring;
        my $namestring = $name->get_namestring;

        # If there is one entry (hash) for the lastname, then it's unique
        if (Biber::Config->get_numofuniquenames($lastname) == 1) {
          $name->set_uniquename(0);
        }
        # Otherwise, if there is one entry (hash) for the lastname plus initials,
        # then it needs the initials to make it unique
        elsif (Biber::Config->get_numofuniquenames($nameinitstring) == 1) {
          $name->set_uniquename(1);
        }
        # Otherwise the name needs to be full to make it unique
        # However, if uniquename biblatex option is "init" (2), then restrict to
        # value 1. Confusing.
        elsif (Biber::Config->get_numofuniquenames($namestring) == 1) {
          $un == 2 ? $name->set_uniquename(1) : $name->set_uniquename(2);
        }
        # Otherwise, if there is more than one entry (hash) for the full name,
        # then set to 0 since nothing will uniqueify this name and it's just
        # misleading to expand it
        elsif (Biber::Config->get_numofuniquenames($namestring) > 1) {
          $name->set_uniquename(0);
        } else {
          $name->set_uniquename(0);
        }
      }
    }
  }
}

=head2 create_uniquelist_info

    Gather the uniquename information as we look through the names

=cut

sub create_uniquelist_info {
  my $self = shift;
  my $bibentries = $self->bib;

  # Reset uniquelist information as we have to generate it again because uniquename
  # information might have changed
  Biber::Config->reset_uniquelistcount;

  foreach my $citekey ( $self->citekeys ) {
    $logger->debug("Generating uniquelist information for '$citekey'");
    my $be = $bibentries->entry($citekey);
    my $bee = $be->get_field('entrytype');
    my $namehash = $be->get_field('namehash');

    if (my $lname = $be->get_field('labelnamename')) {
      my $liststring = '';
      foreach my $name (@{$be->get_field($lname)->names}) {
        my $lastname   = $name->get_lastname;
        my $nameinitstring = $name->get_nameinitstring;
        my $namestring = $name->get_namestring;
        # uniquename is not set so generate uniquelist based on just lastname
        if (not defined($name->get_uniquename)) {
          $liststring .= $lastname . '|';
        }
        # uniquename indicates unique with just lastname
        elsif ($name->get_uniquename eq '0') {
          $liststring .= $lastname . '|';
        }
        # uniquename indicates unique with lastname with initials
        elsif ($name->get_uniquename eq '1') {
          $liststring .= $nameinitstring . '|';
        }
        # uniquename indicates unique with full name
        elsif ($name->get_uniquename eq '2') {
          $liststring .= $namestring . '|';
        }
        Biber::Config->add_uniquelistcount($liststring);
      }
    }
  }
}

=head2 generate_uniquelist

   Generate the per-namelist uniquelist values using the information
   harvested by create_uniquelist_info()

=cut

sub generate_uniquelist {
  my $self = shift;
  my $bibentries = $self->bib;

  foreach my $citekey ( $self->citekeys ) {
    $logger->debug("Creating uniquelist for '$citekey'");
    my $be = $bibentries->entry($citekey);
    my $bee = $be->get_field('entrytype');
    my $namehash = $be->get_field('namehash');

    if (my $lname = $be->get_field('labelnamename')) {
      my $liststring = '';
      my $namefield = $be->get_field($lname);

      foreach my $name (@{$namefield->names}) {
        my $lastname   = $name->get_lastname;
        my $nameinitstring = $name->get_nameinitstring;
        my $namestring = $name->get_namestring;
        # uniquename is not set so generate uniquelist based on just lastname
        if (not defined($name->get_uniquename)) {
          $liststring .= $lastname . '|';
        }
        # uniquename indicates unique with just lastname
        elsif ($name->get_uniquename eq '0') {
          $liststring .= $lastname . '|';
        }
        # uniquename indicates unique with lastname with initials
        elsif ($name->get_uniquename eq '1') {
          $liststring .= $nameinitstring . '|';
        }
        # uniquename indicates unique with full name
        elsif ($name->get_uniquename eq '2') {
          $liststring .= $namestring . '|';
        }
        # list is unique
        if (Biber::Config->get_uniquelistcount($liststring) == 1) {
          last;
        }
      }
      $logger->trace("Setting uniquelist for '$citekey' using '$liststring'");
      $namefield->set_uniquelist($namefield->count_uniquelist($liststring));
    }
  }
}

=head2 sortentries

    Sort the entries according to a certain sorting scheme.
    This method is automatically called by C<prepare>.

=cut

#===========================
# SORTING
#===========================

sub sortentries {
  my $self = shift;
  my $bibentries = $self->bib;
  my @auxcitekeys = $self->citekeys;

  if ( Biber::Config->getoption('fastsort') ) {
    use locale;
    if (Biber::Config->getoption('locale')) {
      my $thislocale = Biber::Config->getoption('locale');
      $logger->debug("Sorting entries with built-in sort (with locale $thislocale) ...");
      setlocale( LC_ALL, $thislocale )
        or $logger->warn("Unavailable locale $thislocale")
    } else {
      $logger->debug("Sorting entries with built-in sort (with locale ", $ENV{LC_COLLATE}, ") ...");
    }
    @auxcitekeys = sort {
      $bibentries->entry($a)->get_field('sortstring') cmp $bibentries->entry($b)->get_field('sortstring')
      } @auxcitekeys;
  } else {
    require Unicode::Collate;
    my $opts = Biber::Config->getoption('collate_options');
    my $collopts;
    unless (ref($opts) eq "HASH") { # opts for this can come in a string from cmd line
      $collopts = eval "{ $opts }" or $logger->logcarp("Incorrect collate_options: $@");
    }
    else {
      $collopts = $opts;
    }
    my $Collator = Unicode::Collate->new( %{$collopts} )
      or $logger->logcarp("Problem with Unicode::Collate options: $@");
    my $UCAversion = $Collator->version();
    $logger->info("Sorting with Unicode::Collate (" .
		  stringify_hash($collopts) . ", UCA version: $UCAversion)");
    @auxcitekeys = sort {
      $Collator->cmp( $bibentries->entry($a)->get_field('sortstring'),
        $bibentries->entry($b)->get_field('sortstring') )
      } @auxcitekeys;
  }
  $self->{citekeys} = [ @auxcitekeys ];

  return;
}

=head2 sortshorthands

    Sort the shorthands according to a certain sorting scheme.
    This is only called if "sortlos" is true

=cut

sub sortshorthands {
  my $self = shift;
  my $bibentries = $self->bib;
  my @auxshorthands = $self->shorthands;

  if ( Biber::Config->getoption('fastsort') ) {
    if (Biber::Config->getoption('locale')) {
      my $thislocale = Biber::Config->getoption('locale');
      $logger->debug("Sorting shorthands with built-in sort (with locale $thislocale) ...");
      setlocale( LC_ALL, $thislocale )
        or $logger->warn("Unavailable locale $thislocale")
    } else {
      $logger->debug("Sorting shorthands with built-in sort (with locale ", $ENV{LC_COLLATE}, ") ...");
    }
    @auxshorthands = sort { $bibentries->entry($a)->get_field('shorthand') cmp $bibentries->entry($b)->get_field('shorthand') } @auxshorthands;
  } else {
    require Unicode::Collate;
    my $opts = Biber::Config->getoption('collate_options');
    my $collopts;
    unless (ref($opts) eq "HASH") { # opts for this can come in a string from cmd line
      $collopts = eval "{ $opts }" or $logger->logcarp("Incorrect collate_options: $@");
    }
    else {
      $collopts = $opts;
    }
    my $Collator = Unicode::Collate->new( %{$collopts} )
      or $logger->logcarp("Problem with Unicode::Collate options: $@");
    my $UCAversion = $Collator->version();
    $logger->info("Sorting with Unicode::Collate (" .
		  stringify_hash($collopts) . ", UCA version: $UCAversion)");
    @auxshorthands = sort {
      $Collator->cmp($bibentries->entry($a)->get_field('shorthand'),
        $bibentries->entry($b)->get_field('shorthand'))
      } @auxshorthands;
  }
  $self->{shorthands} = [ @auxshorthands ];

  return;
}

=head2 prepare

    Post-process and sort all entries before writing the bbl output.
    This is a convenience method that calls C<process_crossref>, C<postprocess>
    and C<sortentries>.

=cut

sub prepare {
  my $self = shift;
  Biber::Config->_init;

  $self->process_missing; # Check for missing citekeys before anything else
  $self->process_sets_and_crossrefs; # Process sets and crossrefs
  $self->postprocess; # in here we generate the label sort string
  $self->sortentries; # then we do a label sort pass
  $self->uniqueness; # Here we generate uniqueness information (extra*, unique* etc.)
  $self->generate_final_sortinfo; # in here we generate the final sort string
  $self->sortentries; # and then we do a final sort pass

  return;
}

=head2 create_bbl_string

    $biber->create_bbl_string()

    Create the .bbl file contents in a string ref
    This is separate from the output to file so that
    the string can be used for debugging and tests.

=cut

sub create_bbl_string {
  my $self = shift;
  my $BBL = ${$self->create_bbl_string_head} . ${$self->create_bbl_string_body};
  return \$BBL;
}

=head2 create_bbl_string_head

    $biber->create_bbl_string_head()

    Create the .bbl file contents header

=cut

sub create_bbl_string_head {
  my $self = shift;
  my $ctrlver = Biber::Config->getblxoption('controlversion');
  my $BBL = <<"EOF";
% \$ biblatex auxiliary file \$
% \$ biblatex version $ctrlver \$
% \$ biber version $VERSION \$
% Do not modify the above lines!
%
% This is an auxiliary file used by the 'biblatex' package.
% This file may safely be deleted. It will be recreated by
% biber or bibtex as required.
%
\\begingroup
\\makeatletter
\\\@ifundefined{ver\@biblatex.sty}
  {\\\@latex\@error
     {Missing 'biblatex' package}
     {The bibliography requires the 'biblatex' package.}
      \\aftergroup\\endinput}
  {}
\\endgroup

EOF
  return \$BBL;
}

=head2 create_bbl_string_body

    $biber->create_bbl_string_body()

    Create the .bbl file body contents in a string ref
    the string can be used for debugging and tests.

=cut

sub create_bbl_string_body {
  my $self = shift;
  my @auxcitekeys = $self->citekeys;
  my $BBL = '';

  $BBL .= "\\preamble{%\n" . $self->{preamble} . "%\n}\n"
    if $self->{preamble};

  # We rely on the order of this array for the order of the .bbl
  # and therefore the .bib
  foreach my $k (@auxcitekeys) {
    ## skip crossrefkeys (those that are directly cited or
    #  crossref'd >= mincrossrefs were previously removed)
    #  EXCEPT those that are also in a set
    next if ( Biber::Config->get_crossrefkey($k) and
      not Biber::Config->get_setparentkey($k) );
    $BBL .= $self->_print_biblatex_entry($k);
  }
  if ( Biber::Config->getoption('sortlos') and $self->shorthands ) {
    $self->sortshorthands;
    $BBL .= "\\lossort\n";
    foreach my $sh ($self->shorthands) {
      $BBL .= "  \\key{$sh}\n";
    }
    $BBL .= "\\endlossort\n";
  }
  $BBL .= "\\endinput\n\n";

#    if ( Biber::Config->getoption('bibencoding') and ! Biber::Config->getoption('unicodebbl') ) {
#        $BBL = encode(Biber::Config->getoption('bibencoding'), $BBL)
#    };

  return \$BBL;
}

=head2 output_to_bbl

    $biber->output_to_bbl($ref_to_bbl_string, $file_name.bbl);

    Write the bbl file for biblatex.

=cut

sub output_to_bbl {
  my $self = shift;
  my $bblstring = shift;
  my $bblfile = shift;

  $logger->debug("Preparing final output...");

  my $mode;

  if ( Biber::Config->getoption('bibencoding') and ! Biber::Config->getoption('unicodebbl') ) {
    $mode = ':encoding(' . Biber::Config->getoption('bibencoding') . ')';
  } else {
    $mode = ":utf8";
  }

  my $BBLFILE = IO::File->new($bblfile, ">$mode")
    or $logger->logcroak("Failed to open $bblfile : $!");

  # $BBLFILE->binmode(':utf8') if Biber::Config->getoption('unicodebbl');

  print $BBLFILE $$bblstring or $logger->logcroak("Failure to write to $bblfile: $!");
  $logger->info("Output to $bblfile");
  close $BBLFILE or $logger->logcroak("Failure to close $bblfile: $!");
  return;
}

=head2 _filedump and _stringdump

    Dump the biber object with Data::Dump for debugging

=cut

sub _filedump {
  my ($self, $file) = @_;
  my $fh = IO::File->new($file, '>') or croak "Can't open file $file for writing";
  print $fh Data::Dump::pp($self);
  close $fh;
  return
}

sub _stringdump {
  my $self = shift ;
  return Data::Dump::pp($self);
}

=head1 AUTHORS

François Charette, C<< <firmicus at gmx.net> >>
Philip Kime C<< <philip at kime.org.uk> >>

=head1 BUGS

Please report any bugs or feature requests on our sourceforge tracker at
L<https://sourceforge.net/tracker2/?func=browse&group_id=228270>.

=head1 COPYRIGHT & LICENSE

Copyright 2009-2010 François Charette and Philip Kime, all rights reserved.

This program is free software; you can redistribute it and/or
modify it under the terms of either:

=over 4

=item * the GNU General Public License as published by the Free
Software Foundation; either version 1, or (at your option) any
later version, or

=item * the Artistic License version 2.0.

=back

=cut

1;

# vim: set tabstop=2 shiftwidth=2 expandtab:
