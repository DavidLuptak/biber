package Biber::Output::biblatexml;
use v5.16;
use strict;
use warnings;
use base 'Biber::Output::base';

use Biber;
use Biber::Config;
use Biber::Constants;
use Biber::Utils;
use List::AllUtils qw( :all );
use Encode;
use IO::File;
use Log::Log4perl qw( :no_extra_logdie_message );
use Text::Wrap;
use XML::Writer;
$Text::Wrap::columns = 80;
my $logger = Log::Log4perl::get_logger('main');

=encoding utf-8

=head1 NAME

Biber::Output::biblatexml - class for biblatexml output of tool mode

=cut


=head2 new

    Initialize a Biber::Output::biblatexml object

=cut

sub new {
  my $class = shift;
  my $obj = shift;
  my $self;
  if (defined($obj) and ref($obj) eq 'HASH') {
    $self = bless $obj, $class;
  }
  else {
    $self = bless {}, $class;
  }

  return $self;
}


=head2 set_output_target_file

    Set the output target file of a Biber::Output::biblatexml object
    A convenience around set_output_target so we can keep track of the
    filename

=cut

sub set_output_target_file {
  my $self = shift;
  my $toolfile = shift;
  # Make the right casing function and store it

  $self->{output_target_file} = $toolfile;
  my $bltxml = 'http://biblatex-biber.sourceforge.net/biblatexml';
  $self->{xml_prefix} = $bltxml;

  my $xml = XML::Writer->new(OUTPUT      => IO::File->new($toolfile, '>:encoding(UTF-8)'),
                             DATA_MODE   => 1,
                             DATA_INDENT => Biber::Config->getoption('tool_indent'),
                             NAMESPACES  => 1,
                             PREFIX_MAP  => {$bltxml => 'bltx'});
  $xml->xmlDecl("UTF-8");
  $xml->comment("Auto-generated by Biber::Output::biblatexml");
  $xml->startTag([$self->{xml_prefix}, 'entries']);
  $self->set_output_target($xml);
}

=head2 set_output_entry

  Set the output for an entry

=cut

sub set_output_entry {
  my $self = shift;
  my $be = shift; # Biber::Entry object
  my $bee = $be->get_field('entrytype');
  my $section = shift; # Section object the entry occurs in
  my $dm = shift; # Data Model object
  my $secnum = $section->number;
  my $key = $be->get_field('citekey');
  my $xml = $self->{output_target};
  my $xml_prefix = $self->{xml_prefix};

  $xml->startTag([$xml_prefix, 'entry'], id => $key, entrytype => $bee);

  foreach my $f ($be->rawfields) {
    # If IDS, CROSSREF and XDATA have been resolved, don't output them
    # We can't use the usual skipout test for fields not to be output
    # as this only refers to .bbl output and not to biblatexml ouput since this
    # latter is not really a "processed" output, it is supposed to be something
    # which could be again used as input and so we don't want to resolve/skip
    # fields like DATE etc.
    if (Biber::Config->getoption('tool_resolve')) {
      next if lc($f) ~~ ['ids', 'xdata', 'crossref'];
    }
    my $value = decode_utf8($be->get_rawfield($f));

    # TODO - ALIASES
    # TODO - XDATA (also in bltxml)

    # Output name fields
    foreach my $namefield (@{$dm->get_fields_of_type('list', 'name')}) {
      next unless my $nf = $be->get_field($namefield);

      # Did we have "and others" in the data?
      if ( $nf->get_morenames ) {
        $xml->startTag([$xml_prefix, $namefield], morenames => 1);
      }
      else {
        $xml->startTag([$xml_prefix, $namefield]);
      }

      # Name loop
      foreach my $n (@{$nf->names}) {
        $n->name_to_biblatexml($xml, $self);
      }

      $xml->endTag();# Names
    }

  #   # Output list fields
  #   foreach my $listfield (@{$dm->get_fields_of_fieldtype('list')}) {
  #     next if $dm->field_is_datatype('name', $listfield); # name is a special list
  #     next if $dm->field_is_skipout($listfield);
  #     if (my $lf = $be->get_field($listfield)) {
  #       if ( lc($be->get_field($listfield)->[-1]) eq Biber::Config->getoption('others_string') ) {
  #         $acc .= "      \\true{more$listfield}\n";
  #         pop @$lf;             # remove the last element in the array
  #       }
  #       my $total = $#$lf + 1;
  #       $acc .= "      \\list{$listfield}{$total}{%\n";
  #       foreach my $f (@$lf) {
  #         $acc .= "        {$f}%\n";
  #       }
  #       $acc .= "      }\n";
  #     }
  #   }

  #   my $namehash = $be->get_field('namehash');
  #   $acc .= "      \\strng{namehash}{$namehash}\n" if $namehash;
  #   my $fullhash = $be->get_field('fullhash');
  #   $acc .= "      \\strng{fullhash}{$fullhash}\n" if $fullhash;

  #   if ( Biber::Config->getblxoption('labelalpha', $bee) ) {
  #     # Might not have been set due to skiplab/dataonly
  #     if (my $label = $be->get_field('labelalpha')) {
  #       $acc .= "      \\field{labelalpha}{$label}\n";
  #     }
  #   }

  #   # This is special, we have to put a marker for sortinit and then replace this string
  #   # on output as it can vary between lists
  #   $acc .= "      <BDS>SORTINIT</BDS>\n";

  #   # The labeldate option determines whether "extrayear" is output
  #   if ( Biber::Config->getblxoption('labeldate', $bee)) {
  #     # Might not have been set due to skiplab/dataonly
  #     if (my $nameyear = $be->get_field('nameyear')) {
  #       if ( Biber::Config->get_seen_nameyear($nameyear) > 1) {
  #         $acc .= "      <BDS>EXTRAYEAR</BDS>\n";
  #       }
  #     }
  #     if (my $ly = $be->get_field('labelyear')) {
  #       $acc .= "      \\field{labelyear}{$ly}\n";
  #     }
  #     if (my $lm = $be->get_field('labelmonth')) {
  #       $acc .= "      \\field{labelmonth}{$lm}\n";
  #     }
  #     if (my $ld = $be->get_field('labelday')) {
  #       $acc .= "      \\field{labelday}{$ld}\n";
  #     }
  #   }

  #   # The labeltitle option determines whether "extratitle" is output
  #   if ( Biber::Config->getblxoption('labeltitle', $bee)) {
  #     # Might not have been set due to skiplab/dataonly
  #     if (my $nametitle = $be->get_field('nametitle')) {
  #       if ( Biber::Config->get_seen_nametitle($nametitle) > 1) {
  #         $acc .= "      <BDS>EXTRATITLE</BDS>\n";
  #       }
  #     }
  #   }

  #   # The labeltitleyear option determines whether "extratitleyear" is output
  #   if ( Biber::Config->getblxoption('labeltitleyear', $bee)) {
  #     # Might not have been set due to skiplab/dataonly
  #     if (my $titleyear = $be->get_field('titleyear')) {
  #       if ( Biber::Config->get_seen_titleyear($titleyear) > 1) {
  #         $acc .= "      <BDS>EXTRATITLEYEAR</BDS>\n";
  #       }
  #     }
  #   }

  #   # labeltitle is always output
  #   if (my $lt = $be->get_field('labeltitle')) {
  #     $acc .= "      \\field{labeltitle}{$lt}\n";
  #   }

  #   # The labelalpha option determines whether "extraalpha" is output
  #   if ( Biber::Config->getblxoption('labelalpha', $bee)) {
  #     # Might not have been set due to skiplab/dataonly
  #     if (my $la = $be->get_field('labelalpha')) {
  #       if (Biber::Config->get_la_disambiguation($la) > 1) {
  #         $acc .= "      <BDS>EXTRAALPHA</BDS>\n";
  #       }
  #     }
  #   }

  #   if ( Biber::Config->getblxoption('labelnumber', $bee) ) {
  #     if (my $sh = $be->get_field('shorthand')) {
  #       $acc .= "      \\field{labelnumber}{$sh}\n";
  #     }
  #     elsif (my $lnum = $be->get_field('labelnumber')) {
  #       $acc .= "      \\field{labelnumber}{$lnum}\n";
  #     }
  #   }

  #   if (defined($be->get_field('singletitle'))) {
  #     $acc .= "      \\true{singletitle}\n";
  #   }

  #   if (my $ck = $be->get_field('clonesourcekey')) {
  #     $acc .= "      \\field{clonesourcekey}{$ck}\n";
  #   }

  #   foreach my $lfield (sort @{$dm->get_fields_of_type('field', 'entrykey')},
  #                       @{$dm->get_fields_of_type('field', 'key')},
  #                       @{$dm->get_fields_of_datatype('integer')},
  #                       @{$dm->get_fields_of_type('field', 'literal')},
  #                       @{$dm->get_fields_of_type('field', 'code')}) {
  #     next if $dm->field_is_skipout($lfield);
  #     if ( ($dm->field_is_nullok($lfield) and
  #           $be->field_exists($lfield)) or
  #          $be->get_field($lfield) ) {
  #       # we skip outputting the crossref or xref when the parent is not cited
  #       # (biblatex manual, section 2.2.3)
  #       # sets are a special case so always output crossref/xref for them since their
  #       # children will always be in the .bbl otherwise they make no sense.
  #       unless ($bee eq 'set') {
  #         next if ($lfield eq 'crossref' and
  #                  not $section->has_citekey($be->get_field('crossref')));
  #         next if ($lfield eq 'xref' and
  #                  not $section->has_citekey($be->get_field('xref')));
  #       }
  #       $acc .= _printfield($be, $lfield, $be->get_field($lfield) );
  #     }
  #   }

  #   foreach my $rfield (@{$dm->get_fields_of_datatype('range')}) {
  #     if ( my $rf = $be->get_field($rfield) ) {
  #       # range fields are an array ref of two-element array refs [range_start, range_end]
  #       # range_end can be be empty for open-ended range or undef
  #       my @pr;
  #       foreach my $f (@$rf) {
  #         if (defined($f->[1])) {
  #           push @pr, $f->[0] . '\bibrangedash' . ($f->[1] ? ' ' . $f->[1] : '');
  #         }
  #         else {
  #           push @pr, $f->[0];
  #         }
  #       }
  #       my $bbl_rf = join('\bibrangessep ', @pr);
  #       $acc .= "      \\field{$rfield}{$bbl_rf}\n";
  #     }
  #   }

  #   foreach my $vfield ((@{$dm->get_fields_of_datatype('verbatim')},
  #                        @{$dm->get_fields_of_datatype('uri')})) {
  #     next if $dm->field_is_skipout($vfield);
  #     if ( my $vf = $be->get_field($vfield) ) {
  #       $acc .= "      \\verb{$vfield}\n";
  #       $acc .= "      \\verb $vf\n      \\endverb\n";
  #     }
  #   }
  #   if ( my $k = $be->get_field('keywords') ) {
  #     $acc .= "      \\keyw{$k}\n";
  #   }
  }

  $xml->endTag();

  # Create an index by keyname for easy retrieval
#  $self->{output_data}{ENTRIES}{$secnum}{index}{$key} = \$acc;

  return;
}


=head2 output

    Tool output method

=cut

sub output {
  my $self = shift;
  my $data = $self->{output_data};
  my $xml = $self->{output_target};
  my $target_string = "Target"; # Default
  if ($self->{output_target_file}) {
    $target_string = $self->{output_target_file};
  }

  # for debugging mainly
  # unless ($target) {
  #   $target = new IO::File '>-';
  # }

  $logger->debug('Preparing final output using class ' . __PACKAGE__ . '...');
  $logger->debug("Writing entries in tool mode");

  # There is only a (pseudo) section "0" in tool mode
  # foreach my $key ($Biber::MASTER->sortlists->get_list(0, 'entry', 'tool')->get_keys) {
  #   out($xml, ${$data->{ENTRIES}{0}{index}{$key}});
  # }

  $xml->endTag();
  $xml->end();

  $logger->info("Output to $target_string");
  return;
}

=head2 create_output_section

    Create the output from the sections data and push it into the
    output object.

=cut

sub create_output_section {
  my $self = shift;
  my $secnum = $Biber::MASTER->get_current_section;
  my $section = $Biber::MASTER->sections->get_section($secnum);


  # We rely on the order of this array for the order of the .bbl
  foreach my $k ($section->get_citekeys) {
    # Regular entry
    my $be = $section->bibentry($k) or biber_error("Cannot find entry with key '$k' to output");
    $self->set_output_entry($be, $section, Biber::Config->get_dm);
  }

  # Make sure the output object knows about the output section
  $self->set_output_section($secnum, $section);

  return;
}


1;

__END__

=head1 AUTHORS

François Charette, C<< <firmicus at ankabut.net> >>
Philip Kime C<< <philip at kime.org.uk> >>

=head1 BUGS

Please report any bugs or feature requests on our sourceforge tracker at
L<https://sourceforge.net/tracker2/?func=browse&group_id=228270>.

=head1 COPYRIGHT & LICENSE

Copyright 2009-2013 François Charette and Philip Kime, all rights reserved.

This module is free software.  You can redistribute it and/or
modify it under the terms of the Artistic License 2.0.

This program is distributed in the hope that it will be useful,
but without any warranty; without even the implied warranty of
merchantability or fitness for a particular purpose.

=cut
