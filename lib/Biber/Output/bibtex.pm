package Biber::Output::bibtex;
use 5.014000;
use strict;
use warnings;
use base 'Biber::Output::base';

use Biber::Config;
use Biber::Constants;
use Biber::Entry;
use Biber::Utils;
use List::AllUtils qw( :all );
use IO::File;
use Log::Log4perl qw( :no_extra_logdie_message );
my $logger = Log::Log4perl::get_logger('main');

=encoding utf-8

=head1 NAME

Biber::Output::bibtex - class for Biber output of .bib

=cut

=head2 new

    Initialize a Biber::Output::bibtex object

=cut

sub new {
  my $class = shift;
  my $obj = shift;
  my $self = $class->SUPER::new($obj);
  my $beta = $Biber::Config::BETA_VERSION ? '(beta)' : '';

  $self->{output_data}{HEAD} = "% Auto-generated by Biber version $Biber::Config::VERSION $beta\n";

  return $self;
}


=head2 set_output_target_file

    Set the output target file of a Biber::Output::bibtex object
    A convenience around set_output_target so we can keep track of the
    filename
    Always output UTF-8

=cut

sub set_output_target_file {
  my $self = shift;
  my $bibfile = shift;
  $self->{output_target_file} = $bibfile;
  my $BIBFILE = IO::File->new($bibfile, ">:encoding(UTF-8)");
  $self->set_output_target($BIBFILE);
}

=head2 _printfield

  Add the .bib for a text field to the output accumulator.

=cut

sub _printfield {
  my ($be, $field, $str) = @_;
  my $field_type = 'field';

  return '  ' . uc($field) . " = {$str}\n";
}

=head2 set_output_keyalias

  Dummy as aliases are not global to a section with .bib output

=cut

sub set_output_keyalias {
  return;
}


=head2 set_output_entry

  Set the .bbl output for an entry. This is the meat of
  the .bbl output

=cut

sub set_output_entry {
  my $self = shift;
  my $be = shift; # Biber::Entry object
  my $bee = $be->get_field('entrytype');
  my $section = shift; # Section object the entry occurs in
  my $dm = shift; # Data Model object
  my $acc = '';
  my $secnum = $section->number;
  my $key = $be->get_field('citekey');

  $acc .= '@' . uc($bee) . "{$key,\n";

  if (my $opts = $be->get_field('options')) {
    $acc .= "  OPTIONS = {$opts},\n";
  }

  if (my $ids = $be->get_field('ids')) {
    $acc .= "  IDS = {$ids}\n";
  }

  # Generate set information
  if ( $bee eq 'set' ) {   # Set parents get \set entry ...
    $acc .= '  ENTRYSET = {' . $be->get_field('entryset') . "}\n";
  }

  # Output name fields

  # then names themselves
  foreach my $namefield (@{$dm->get_fields_of_type('list', 'name')}) {
    if ( my $nf = $be->get_field($namefield) ) {

      # Copy per-list options to the actual labelname too
      $acc .= '  ' . uc($namefield) . ' = {';
      foreach my $n (@{$nf->names}) {
        $acc .= $n->name_to_bib;
      }

      # Did we have "and others" originally
      if ( $nf->get_morenames ) {
        $acc .= ' and others';
      }

      $acc .= "}\n";

    }

  }

  # Output list fields
  foreach my $listfield (@{$dm->get_fields_of_fieldtype('list')}) {
    next if $dm->field_is_datatype('name', $listfield); # name is a special list
    if (my $lf = $be->get_field($listfield)) {
      foreach my $f (@$lf) {
        $acc .= '  ' . uc($listfield) . ' = ' . join(' and ', @$lf) . "}\n";
      }
    }
  }

  foreach my $lfield (sort @{$dm->get_fields_of_type('field', 'entrykey')},
                           @{$dm->get_fields_of_type('field', 'key')},
                           @{$dm->get_fields_of_datatype('integer')},
                           @{$dm->get_fields_of_type('field', 'literal')},
                           @{$dm->get_fields_of_type('field', 'code')}) {
    if ( ($dm->field_is_nullok($lfield) and
          $be->field_exists($lfield)) or
         $be->get_field($lfield) ) {
      $acc .= _printfield($be, $lfield, $be->get_field($lfield) );
    }
  }

  foreach my $rfield (@{$dm->get_fields_of_datatype('range')}) {
    if ( my $rf = $be->get_field($rfield) ) {
      # range fields are an array ref of two-element array refs [range_start, range_end]
      # range_end can be be empty for open-ended range or undef
      my @pr;
      foreach my $f (@$rf) {
        if (defined($f->[1])) {
          push @pr, $f->[0] . '-' . ($f->[1] ? ' ' . $f->[1] : '');
        }
        else {
          push @pr, $f->[0];
        }
      }
      my $bbl_rf = join(',', @pr);
      $acc .= '  ' . uc($rfield) . " = {$bbl_rf}\n";
    }
  }

  foreach my $vfield (@{$dm->get_fields_of_datatype('verbatim')}) {
    if ( my $vf = $be->get_field($vfield) ) {
      $acc .= '  ' . uc($vfield) . " = {$vf}\n";
    }
  }
  if ( my $k = $be->get_field('keywords') ) {
    $acc .= "  KEYWORDS = {$k}\n";
  }

  $acc .= "}\n\n";

  # Create an index by keyname for easy retrieval
  $self->{output_data}{ENTRIES}{$secnum}{index}{$key} = \$acc;

  return;
}


=head2 output

    BBL output method - this takes care to output entries in the explicit order
    derived from the virtual order of the citekeys after sortkey sorting.

=cut

sub output {
  my $self = shift;
  my $data = $self->{output_data};
  my $target = $self->{output_target};
  my $target_string = "Target"; # Default
  if ($self->{output_target_file}) {
    $target_string = $self->{output_target_file};
  }

  # for debugging mainly
  unless ($target) {
    $target = new IO::File '>-';
  }

  $logger->debug('Preparing final output using class ' . __PACKAGE__ . '...');

  print $target $data->{HEAD};

  foreach my $secnum (sort keys %{$data->{ENTRIES}}) {
    $logger->debug("Writing entries for section $secnum");

    print $target "% SECTION $secnum\n\n";
    my $section = $self->get_output_section($secnum);

    # This sort is cosmetic, just to order the lists in a predictable way in the .bib
    foreach my $list (sort {$a->get_label cmp $b->get_label} @{$Biber::MASTER->sortlists->get_lists_for_section($secnum)}) {
      next unless $list->count_keys; # skip empty lists
      my $listlabel = $list->get_label;
      my $listtype = $list->get_type;
      $logger->debug("Writing entries in '$listtype' list '$listlabel'");

      print $target "% SORTLIST ($listtype) $listlabel\n\n";

      # The order of this array is the sorted order
      foreach my $k ($list->get_keys) {
        $logger->debug("Writing entry for key '$k'");
        if ($listtype eq 'entry') {
          my $entry = $data->{ENTRIES}{$secnum}{index}{$k};

          # Instantiate any dynamic, list specific entry information
          my $entry_string = $list->instantiate_entry($entry, $k);

          # If requested to convert UTF-8 to macros ...
          if (Biber::Config->getoption('bblsafechars')) {
            $entry_string = latex_recode_output($entry_string);
          }

          print $target $entry_string;
        }
      }

    }
  }

  $logger->info("Output to $target_string");
  close $target;
  return;
}

1;

__END__

=head1 AUTHORS

François Charette, C<< <firmicus at ankabut.net> >>
Philip Kime C<< <philip at kime.org.uk> >>

=head1 BUGS

Please report any bugs or feature requests on our sourceforge tracker at
L<https://sourceforge.net/tracker2/?func=browse&group_id=228270>.

=head1 COPYRIGHT & LICENSE

Copyright 2009-2012 François Charette and Philip Kime, all rights reserved.

This module is free software.  You can redistribute it and/or
modify it under the terms of the Artistic License 2.0.

This program is distributed in the hope that it will be useful,
but without any warranty; without even the implied warranty of
merchantability or fitness for a particular purpose.

=cut
