package Biber::Output::DOT;
use 5.014000;
use strict;
use warnings;
use base 'Biber::Output::Base';

use Biber::Config;
use Biber::Constants;
use Biber::Entry;
use Biber::Utils;
use List::AllUtils qw( :all );
use IO::File;
use Log::Log4perl qw( :no_extra_logdie_message );
use Graph::Easy;
my $logger = Log::Log4perl::get_logger('main');

=encoding utf-8

=head1 NAME

Biber::Output::DOT - class for Biber output of GraphViz .dot files

=cut

=head2 new

    Initialize a Biber::Output::DOT object

=cut

sub new {
  my $class = shift;
  my $obj = shift;
  my $self = $class->SUPER::new($obj);

  $self->set_output_head("// Begin .dot output generated by Biber::Output::DOT\n");
  return $self;
}

=head2 set_output_target_file

    Set the output target file of a Biber::Output::DOT object
    A convenience around set_output_target so we can keep track of the
    filename

=cut

sub set_output_target_file {
  my $self = shift;
  my $dotfile = shift;
  $self->{output_target_file} = $dotfile;
  my $enc_out;
  $enc_out = ':encoding(UTF-8)';
  my $DOTFILE = IO::File->new($dotfile, ">$enc_out");
  $self->set_output_target($DOTFILE);
}


=head2 set_output_entry

  We don't use this, we output everything in one go at the end

=cut

sub set_output_entry {
  return;
}

=head2 create_output_section

  We don't use this, we output everything in one go at the end

=cut

sub create_output_section {
  return;
}

=head2 output

  Create a graph of the required things and save to .dot format

=cut

sub output {
  my $self = shift;
  my $biber = $Biber::MASTER;
  my $data = $self->{output_data};
  my $target = $self->{output_target};
  my $target_string = "Target"; # Default
  if ($self->{output_target_file}) {
    $target_string = $self->{output_target_file};
  }

  # for debugging mainly
  unless ($target) {
    $target = new IO::File '>-';
  }

  $logger->debug('Preparing final output using class ' . __PACKAGE__ . '...');

  $logger->info("Writing '$target_string' with encoding 'UTF-8'");

  print $target $data->{HEAD};

  my $gopts = Biber::Config->getoption('graph');
  my $graph = Graph::Easy->new();
  my $context = $graph;

  # Loop over sections. We may not show sections but we set the graph
  # context to the section if we do
  foreach my $section (@{$biber->sections->get_sections}) {
    my $secnum = $section->number;
    if ($gopts->{section}) {
      my $section_group = $graph->add_group("section_${secnum}");
      $section_group->set_attribute('label', "Section $secnum");
      $section_group->set_attribute('fill', '#fce3fa');
      $context = $section_group;
    }

    foreach my $be ($section->bibentries->entries) {
      my $citekey = $be->get_field('citekey');
      my $et = uc($be->get_field('entrytype'));
      # uncited entries are a different colour
      my $c = $section->has_citekey($citekey) ? '#a0d0ff' : '#e3e388';
      if ($gopts->{entry}) { # If granularity is at the level of entries
        my $entry_node = $context->add_node("section_${secnum}/${citekey}");
        $entry_node->set_attribute('label', "$citekey ($et)");
        $entry_node->set_attribute('fill', $c);
      }
      elsif ($gopts->{field}) { # If granularity is at the level of fields
        my $entry_group = $context->add_group("section_${secnum}/${citekey}");
        $entry_group->set_attribute('label', "$citekey ($et)");
        $entry_group->set_attribute('fill', $c);
        foreach my $field ($be->datafields) {
          my $field_node = $entry_group->add_node("section_${secnum}/${citekey}/${field}");
          $field_node->set_attribute('label', uc($field));
        }
      }
    }

    # crossrefs
    _graph_inheritance('crossref', $graph, $context, $secnum);

    # xdata
    _graph_inheritance('xdata', $graph, $context, $secnum);

    # xref
    _graph_xref($graph, $context, $secnum);

  }

  print $target $graph->as_graphviz;

  $logger->info("Output to $target_string");
  close $target;
  return;
}

sub _graph_xref {
  my ($graph, $context, $secnum) = @_;
  my $gopts = Biber::Config->getoption('graph');

  if (my $gr = Biber::Config->get_inheritance_graph('xref')) {
    while (my ($f_entry, $v) = each %$gr) {
      while (my (undef, $w) = each %$v) {
        while (my ($t_entry, undef) = each %$w) {
          # Connect the two nodes if they exist - since we
          # are using all entries (not just cited), they only won't
          # exist if they are not in this section in which case
          # we don't want to auto-create them when creating the edge
          if (($graph->group("section_${secnum}/${f_entry}") or
               $graph->node("section_${secnum}/${f_entry}")) and
              ($graph->group("section_${secnum}/${t_entry}") or
               $graph->node("section_${secnum}/${t_entry}"))) {
            my $e = $context->add_edge_once("section_${secnum}/${f_entry}", "section_${secnum}/${t_entry}");
            $e->set_attribute('style', 'dotted');
          }
        }
      }
    }
  }
}

sub _graph_inheritance {
  my ($type, $graph, $context, $secnum) = @_;
  my $gopts = Biber::Config->getoption('graph');
  my $edgestyle;

  given ($type) {
    when ('crossref') {
      $edgestyle = 'solid';
    }
    when ('xdata') {
      $edgestyle = 'dashed';
    }
  }

  if ($gopts->{$type} and
      my $gr = Biber::Config->get_inheritance_graph($type)) {
    # Just show the entries, no fields
    if ($gopts->{entry}) {
      while (my ($f_entry, $v) = each %$gr) {
        while (my (undef, $w) = each %$v) {
          while (my ($t_entry, undef) = each %$w) {
            # Connect the two nodes if they exist - since we
            # are using all entries (not just cited), they only won't
            # exist if they are not in this section in which case
            # we don't want to auto-create them when creating the edge
            if ($graph->node("section_${secnum}/${f_entry}") and
                $graph->node("section_${secnum}/${t_entry}")) {
              my $e = $context->add_edge_once("section_${secnum}/${f_entry}", "section_${secnum}/${t_entry}");
              $e->set_attribute('style', $edgestyle);
            }
          }
        }
      }
    }
    # Show fields too
    elsif ($gopts->{field}) {
      while (my ($f_entry, $v) = each %$gr) {
        while (my ($f_field, $w) = each %$v) {
          while (my ($t_entry, $t_field) = each %$w) {
            if ($graph->group("section_${secnum}/${f_entry}") and
                $graph->group("section_${secnum}/${t_entry}")) {
              my $e = $context->add_edge_once("section_${secnum}/${f_entry}/${f_field}", "section_${secnum}/${t_entry}/${t_field}");
              $e->set_attribute('style', $edgestyle);
            }
          }
        }
      }
    }
  }
}


1;

__END__

=head1 AUTHORS

François Charette, C<< <firmicus at gmx.net> >>
Philip Kime C<< <philip at kime.org.uk> >>

=head1 BUGS

Please report any bugs or feature requests on our sourceforge tracker at
L<https://sourceforge.net/tracker2/?func=browse&group_id=228270>.

=head1 COPYRIGHT & LICENSE

Copyright 2009-2011 François Charette and Philip Kime, all rights reserved.

This module is free software.  You can redistribute it and/or
modify it under the terms of the Artistic License 2.0.

This program is distributed in the hope that it will be useful,
but without any warranty; without even the implied warranty of
merchantability or fitness for a particular purpose.

=cut
